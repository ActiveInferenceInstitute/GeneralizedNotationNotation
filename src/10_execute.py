"""
GNN Processing Pipeline - Step 10: Execute Rendered Simulators

This script orchestrates the execution of rendered GNN simulators,
primarily focusing on PyMDP scripts generated by Step 9.

Usage:
    python 10_execute.py [options]
    (Typically called by main.py)
    
Options:
    Same as main.py (passes arguments through, especially output_dir and verbose)
"""

import sys
from pathlib import Path
import logging
import argparse
import os # For LOG_LEVEL in standalone

# Attempt to import the new logging utility
try:
    from utils.logging_utils import setup_standalone_logging
except ImportError:
    current_script_path_for_util = Path(__file__).resolve()
    project_root_for_util = current_script_path_for_util.parent.parent
    paths_to_try = [str(project_root_for_util), str(project_root_for_util / "src")]
    original_sys_path = list(sys.path)
    for p_try in paths_to_try:
        if p_try not in sys.path:
            sys.path.insert(0, p_try)
    try:
        from utils.logging_utils import setup_standalone_logging
    except ImportError:
        setup_standalone_logging = None
        _temp_logger_name = __name__ if __name__ != "__main__" else "src.10_execute_import_warning"
        _temp_logger = logging.getLogger(_temp_logger_name)
        if not _temp_logger.hasHandlers():
            if not logging.getLogger().hasHandlers():
                logging.basicConfig(level=logging.WARNING, stream=sys.stderr)
            else:
                 _temp_logger.addHandler(logging.StreamHandler(sys.stderr))
                 _temp_logger.propagate = False
        _temp_logger.warning(
            "Could not import setup_standalone_logging from utils.logging_utils. Standalone logging might be basic."
        )
    finally:
        sys.path = original_sys_path

# Logger for this pipeline step
logger = logging.getLogger(__name__) # GNN_Pipeline.10_execute or __main__

# Attempt to import the runner function from the execute module
try:
    # If 10_execute.py is in src/ and pymdp_runner.py is in src/execute/
    from execute import pymdp_runner 
except ImportError:
    # Fallback if path issues, try to adjust sys.path
    # This assumes 10_execute.py is in src/
    sys.path.insert(0, str(Path(__file__).resolve().parent))
    try:
        from execute import pymdp_runner
    except ImportError as e:
        logger.error(f"Error: Could not import pymdp_runner from execute module: {e}")
        logger.error("Ensure src/execute/pymdp_runner.py exists and src/ is discoverable.")
        pymdp_runner = None # Ensure it exists for later checks

def main(args: argparse.Namespace) -> int:
    """Main function for the GNN model execution step (Step 10).

    This function serves as the entry point for executing rendered GNN simulators.
    It primarily focuses on orchestrating the execution of PyMDP scripts generated
    by Step 9, using the `pymdp_runner` module.

    Args:
        args (argparse.Namespace):
            Parsed command-line arguments from `main.py` or standalone execution.
            Expected attributes include: output_dir (PathLike), recursive (bool),
            and verbose (bool).

    Returns:
        int: 0 for success, 1 for failure.
    """
    # Logger level for this script's logger (__name__) should be set by main.py
    # based on args.verbose, or by standalone __main__ block.

    logger.info(f"▶️ Starting Step 10: Execute Rendered Simulators ({Path(__file__).name})")
    if args.verbose:
        logger.debug(f"  Pipeline arguments received: {args}")

    if not pymdp_runner or not hasattr(pymdp_runner, 'run_pymdp_scripts'):
        logger.error("❌ PyMDP runner module or function not loaded. Cannot proceed with execution step.")
        return 1 # Indicate failure

    logger.info("  Executing PyMDP rendered scripts...")
    
    # Key arguments for the runner:
    # - args.output_dir: This is the main pipeline output directory.
    #   The runner will construct the path to <output_dir>/gnn_rendered_simulators/pymdp/ from this.
    # - args.recursive: From main pipeline args, to control search within the pymdp folder.
    # - args.verbose: To control verbosity of the runner itself.
    
    try:
        success = pymdp_runner.run_pymdp_scripts(
            pipeline_output_dir=args.output_dir,
            recursive_search=args.recursive, # Assumes main.py's recursive applies here
            verbose=args.verbose
        )
        
        if success:
            logger.info("✅ All found PyMDP scripts executed successfully or no scripts were found to run.")
            logger.info(f"✅ Step 10: Execute Rendered Simulators ({Path(__file__).name}) - COMPLETED")
            return 0 # Indicate success
        else:
            logger.error("❌ Some PyMDP scripts failed during execution.")
            logger.error(f"❌ Step 10: Execute Rendered Simulators ({Path(__file__).name}) - FAILED")
            return 1 # Indicate failure
            
    except Exception as e:
        logger.error(f"❌ An unexpected error occurred during the execution step: {e}", exc_info=args.verbose)
        logger.error(f"❌ Step 10: Execute Rendered Simulators ({Path(__file__).name}) - FAILED CRITICALLY")
        return 1 # Indicate critical failure of the step itself

if __name__ == '__main__':
    # Basic configuration for running this script standalone
    # log_level_str = os.environ.get("LOG_LEVEL", "INFO").upper()
    # log_level = getattr(logging, log_level_str, logging.INFO)
    # logging.basicConfig(
    #     level=log_level,
    #     format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    #     datefmt="%Y-%m-%d %H:%M:%S"
    # )

    # Create a dummy args object mimicking what main.py would provide
    parser = argparse.ArgumentParser(description="GNN Pipeline - Step 10: Execute Rendered Simulators (Standalone)")
    # Default output_dir for standalone: ../output (relative to src/ where this script is)
    script_dir = Path(__file__).resolve().parent
    project_root_for_defaults = script_dir.parent
    default_pipeline_output_dir = project_root_for_defaults / "output"

    parser.add_argument("--output-dir", type=Path, default=default_pipeline_output_dir, # Changed to Path type
                        help=f"Main pipeline output directory (default: {default_pipeline_output_dir.relative_to(project_root_for_defaults) if default_pipeline_output_dir.is_relative_to(project_root_for_defaults) else default_pipeline_output_dir})")
    parser.add_argument("--recursive", action=argparse.BooleanOptionalAction, default=True, # Keep True if sensible default for standalone execution of this step
                        help="Recursively search for PyMDP scripts in their base output folder.")
    parser.add_argument("--verbose", action=argparse.BooleanOptionalAction, default=False, # Default False for standalone consistency
                        help="Enable verbose output for this script and the runner.")
    # Removed --target-dir placeholder as it's not used by this script.

    parsed_args = parser.parse_args()

    # Setup logging for standalone execution
    log_level_to_set = logging.DEBUG if parsed_args.verbose else logging.INFO
    if setup_standalone_logging:
        setup_standalone_logging(level=log_level_to_set, logger_name=__name__)
    else:
        if not logging.getLogger().hasHandlers():
            logging.basicConfig(
                level=log_level_to_set,
                format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
                stream=sys.stdout
            )
        logging.getLogger(__name__).setLevel(log_level_to_set)
        logging.getLogger(__name__).warning("Using fallback basic logging due to missing setup_standalone_logging utility.")

    # If verbose, also set the pymdp_runner's logger to DEBUG for more detailed output from it.
    if parsed_args.verbose:
        if pymdp_runner and hasattr(pymdp_runner, '__name__'):
            logging.getLogger(pymdp_runner.__name__).setLevel(logging.DEBUG)
            logging.getLogger(__name__).debug(f"Verbose logging extended to '{pymdp_runner.__name__}' module.")
        else:
            logging.getLogger(__name__).debug("pymdp_runner module not available or has no __name__, cannot set its verbose level.")

    # Quieten other noisy libraries if necessary
    logging.getLogger('matplotlib').setLevel(logging.WARNING)

    sys.exit(main(parsed_args)) 