"""
Templates for PyMDP code generation from GNN specifications.

This module contains templates and template generation functions used by the PyMDP renderer.
Separating templates from converter logic makes the code more maintainable and modular.
"""

import logging
from typing import Dict, List, Any, Optional

logger = logging.getLogger(__name__)

# --- Template Sections ---

IMPORTS_TEMPLATE = """#!/usr/bin/env python3
\"\"\"
PyMDP Agent Script - {model_name}

Generated by GNN PyMDP Renderer
\"\"\"

# =============================================================================
# WARNING: This is an automatically generated script from GNN
# If no matrix parameters were provided in the GNN spec, this script will
# contain minimal placeholder matrices that may not execute correctly.
# It is intended for basic structure only and may need manual adjustment.
# =============================================================================

import numpy as np
from pymdp.agent import Agent
from pymdp import utils
from pymdp import maths
import copy
import sys
import inspect
import traceback
"""

CONVERSION_SUMMARY_TEMPLATE = """
# --- GNN to PyMDP Conversion Summary ---
{summary_lines}
# --- End of GNN to PyMDP Conversion Summary ---
"""

DEBUG_BLOCK_TEMPLATE = """
print('--- PyMDP Runtime Debug ---')
try:
    import pymdp
    import inspect 
    import traceback 
    import ast
    import json
    import os
    from datetime import datetime
    from pathlib import Path

    # try:
    #     print(f'AGENT_SCRIPT: Imported pymdp version: {{pymdp.__version__}}') # Commented out
    # except AttributeError:
    #     print('AGENT_SCRIPT: pymdp.__version__ attribute not found.') # Commented out
    # print(f'AGENT_SCRIPT: pymdp module location: {{pymdp.__file__}}') # Commented out
    from pymdp.agent import Agent
    print(f'AGENT_SCRIPT: Imported Agent: {{Agent}}')
    print(f'AGENT_SCRIPT: Agent module location: {{inspect.getfile(Agent)}}')
    print('AGENT_SCRIPT: Checking for required variables in global scope:')
    print(f"  AGENT_SCRIPT: A = {{A if 'A' in globals() else 'Not Defined'}}")
    print(f"  AGENT_SCRIPT: B = {{B if 'B' in globals() else 'Not Defined'}}")
    print(f"  AGENT_SCRIPT: C = {{C if 'C' in globals() else 'Not Defined'}}")
    print(f"  AGENT_SCRIPT: D = {{D if 'D' in globals() else 'Not Defined'}}")
    print(f"  AGENT_SCRIPT: E = {{E if 'E' in globals() else 'Not Defined'}}")
    print(f"  AGENT_SCRIPT: control_fac_idx = {{control_fac_idx if 'control_fac_idx' in globals() else 'Not Defined'}}")
    print('  AGENT_SCRIPT: action_names = {action_names_dict_str}')
    print('  AGENT_SCRIPT: qs_initial = {qs_initial_str}')
    print('  AGENT_SCRIPT: agent_hyperparams = {agent_hyperparams_dict_str}')
    
    # Save matrix information to file if PYMDP_OUTPUT_DIR is set
    output_dir_env = os.environ.get('PYMDP_OUTPUT_DIR')
    if output_dir_env:
        output_dir = Path(output_dir_env)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Save matrix information
        matrix_info = {{
            "timestamp": datetime.now().isoformat(),
            "script_name": __file__ if '__file__' in globals() else "unknown_script",
            "matrices": {{
                "A": str(A) if 'A' in globals() and A is not None else None,
                "B": str(B) if 'B' in globals() and B is not None else None,
                "C": str(C) if 'C' in globals() and C is not None else None,
                "D": str(D) if 'D' in globals() and D is not None else None,
                "E": str(E) if 'E' in globals() and E is not None else None
            }},
            "parameters": {{
                "control_fac_idx": str(control_fac_idx) if 'control_fac_idx' in globals() else None,
                "action_names": "{action_names_dict_str}",
                "qs_initial": "{qs_initial_str}",
                "agent_hyperparams": "{agent_hyperparams_dict_str}"
            }}
        }}
        
        matrix_file = output_dir / "matrices_extracted.json"
        with open(matrix_file, 'w') as f:
            json.dump(matrix_info, f, indent=2)
        print(f'AGENT_SCRIPT: Saved matrix information to {{matrix_file}}')
    
    print('AGENT_SCRIPT: Attempting to instantiate agent with defined parameters for debug...')
    
    local_agent_hyperparams_str_val = '{agent_hyperparams_dict_str}'

    agent_params_for_debug = {{}}
    if local_agent_hyperparams_str_val and local_agent_hyperparams_str_val.strip() and local_agent_hyperparams_str_val.strip() != '{{}}':
        try:
            agent_params_for_debug = ast.literal_eval(local_agent_hyperparams_str_val)
            if not isinstance(agent_params_for_debug, dict):
                print("AGENT_SCRIPT: Debug - Parsed agent_hyperparams_dict_str ('" + local_agent_hyperparams_str_val + "') was not a dict.")
                agent_params_for_debug = {{}} 
        except Exception as e_hyper_parse:
            print("AGENT_SCRIPT: Debug - Error parsing agent_hyperparams_dict_str ('" + local_agent_hyperparams_str_val + "'): " + str(e_hyper_parse))
            agent_params_for_debug = {{}}
    else:
        print("AGENT_SCRIPT: Debug - agent_hyperparams_dict_str ('" + local_agent_hyperparams_str_val + "') is empty or '{{}}'. Using empty dict for debug agent.")
    
    debug_params_copy = {{k: v for k, v in agent_params_for_debug.items() if not (isinstance(v, str) and v == 'None')}}
    
    # Attempt agent instantiation and save results
    agent_instantiation_result = {{
        "timestamp": datetime.now().isoformat(),
        "success": False,
        "error": None,
        "agent_info": None
    }}
    
    try:
        temp_agent = Agent(**debug_params_copy)
        print(f'AGENT_SCRIPT: Debug agent successfully instantiated: {{temp_agent}}')
        agent_instantiation_result["success"] = True
        agent_instantiation_result["agent_info"] = str(temp_agent)
        
        # Save successful instantiation info
        if output_dir_env:
            instantiation_file = output_dir / "agent_instantiation_result.json"
            with open(instantiation_file, 'w') as f:
                json.dump(agent_instantiation_result, f, indent=2)
            print(f'AGENT_SCRIPT: Saved agent instantiation result to {{instantiation_file}}')
            
    except Exception as e_agent:
        agent_instantiation_result["success"] = False
        agent_instantiation_result["error"] = str(e_agent)
        print(f'AGENT_SCRIPT: Error during agent instantiation: {{e_agent}}')
        
        # Save failed instantiation info
        if output_dir_env:
            instantiation_file = output_dir / "agent_instantiation_result.json"
            with open(instantiation_file, 'w') as f:
                json.dump(agent_instantiation_result, f, indent=2)
            print(f'AGENT_SCRIPT: Saved agent instantiation error to {{instantiation_file}}')
        
except Exception as e_debug:
    print(f'AGENT_SCRIPT: Error during PyMDP runtime debug: {{e_debug}}')
    print("AGENT_SCRIPT: Traceback:")
    print(traceback.format_exc())
    
    # Save debug error if possible
    output_dir_env = os.environ.get('PYMDP_OUTPUT_DIR')
    if output_dir_env:
        try:
            output_dir = Path(output_dir_env)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            error_info = {{
                "timestamp": datetime.now().isoformat(),
                "error": str(e_debug),
                "traceback": traceback.format_exc()
            }}
            
            error_file = output_dir / "debug_error.json"
            with open(error_file, 'w') as f:
                json.dump(error_info, f, indent=2)
            print(f'AGENT_SCRIPT: Saved debug error to {{error_file}}')
        except Exception as e_save:
            print(f'AGENT_SCRIPT: Could not save debug error: {{e_save}}')
            
print('--- End PyMDP Runtime Debug ---')
"""


def generate_file_header(model_name: str) -> str:
    """Generate the file header with imports and module docstring."""
    return IMPORTS_TEMPLATE.format(model_name=model_name)


def generate_conversion_summary(log_entries: List[str]) -> str:
    """Generate the conversion summary section from log entries."""
    summary_lines = "\n".join([f"# {entry}" for entry in log_entries])
    return CONVERSION_SUMMARY_TEMPLATE.format(summary_lines=summary_lines)


def generate_debug_block(
    action_names_dict_str: str, 
    qs_initial_str: str,
    agent_hyperparams_dict_str: str
) -> str:
    """Generate the debug block for the PyMDP script."""
    return DEBUG_BLOCK_TEMPLATE.format(
        action_names_dict_str=action_names_dict_str,
        qs_initial_str=qs_initial_str,
        agent_hyperparams_dict_str=agent_hyperparams_dict_str
    )


def generate_example_usage_template(
    model_name: str,
    num_modalities: int,
    num_factors: int, 
    control_factor_indices: List[int],
    sim_timesteps: int = 5,
    use_gp_copy: bool = True,
    print_obs: bool = True,
    print_beliefs: bool = True,
    print_actions: bool = True,
    print_states: bool = True
) -> List[str]:
    """
    Generate example usage code for the PyMDP script.
    
    Args:
        model_name: Name of the agent model
        num_modalities: Number of observation modalities
        num_factors: Number of hidden state factors
        control_factor_indices: List of indices for controllable factors
        sim_timesteps: Number of simulation timesteps
        use_gp_copy: Whether to use a copy of the generative process
        print_obs: Whether to print observations
        print_beliefs: Whether to print beliefs
        print_actions: Whether to print actions
        print_states: Whether to print true states
        
    Returns:
        List of code lines for the example usage section
    """
    usage_lines = ["", "# --- Example Usage ---", "if __name__ == '__main__':"]
    indent = "    "

    # Initialize agent
    usage_lines.append(f"{indent}# Initialize agent (already done above)")
    usage_lines.append(f"{indent}# agent = {model_name}  # Agent is already instantiated above as 'agent'")
    usage_lines.append(f"{indent}print(f\"Agent '{model_name}' initialized with {{agent.num_factors if hasattr(agent, 'num_factors') else 'N/A'}} factors and {{agent.num_modalities if hasattr(agent, 'num_modalities') else 'N/A'}} modalities.\")")
    
    # Define observation and state names for display
    usage_lines.append(f"{indent}# Define names for display purposes")
    usage_lines.append(f"{indent}obs_names = [f'Modality_{{i}}' for i in range({num_modalities})] if {num_modalities} > 0 else []")
    usage_lines.append(f"{indent}state_names = [f'Factor_{{i}}' for i in range({num_factors})] if {num_factors} > 0 else []")
    usage_lines.append(f"{indent}num_modalities = {num_modalities}")
    usage_lines.append(f"{indent}num_factors = {num_factors}")
    usage_lines.append(f"{indent}control_fac_idx = {control_factor_indices}")

    # Initial observation and state
    default_o = [0] * num_modalities if num_modalities > 0 else []
    usage_lines.append(f"{indent}o_current = {default_o} # Example initial observation (e.g. first outcome for each modality)")
    
    default_s = [0] * num_factors if num_factors > 0 else []
    usage_lines.append(f"{indent}s_current = {default_s} # Example initial true states for simulation")

    # Simulation parameters
    usage_lines.append(f"{indent}T = {sim_timesteps} # Number of timesteps")

    # Generative process setup
    if use_gp_copy:
        usage_lines.append(f"{indent}A_gen_process = copy.deepcopy(A)")
        usage_lines.append(f"{indent}B_gen_process = copy.deepcopy(B)")
    else:
        usage_lines.append(f"{indent}A_gen_process = A")
        usage_lines.append(f"{indent}B_gen_process = B")
    
    # Simulation loop
    usage_lines.append("")
    usage_lines.append(f"{indent}for t_step in range(T):")
    inner_indent = indent * 2

    # Print observations
    if print_obs:
        usage_lines.append(f"{inner_indent}print(f\"\\n--- Timestep {{t_step + 1}} ---\")")
        usage_lines.append(f"{inner_indent}if o_current is not None:")
        usage_lines.append(f"{inner_indent}{indent}for g_idx, o_val in enumerate(o_current):")
        usage_lines.append(f"{inner_indent}{indent}{indent}print(f\"Observation ({{obs_names[g_idx] if obs_names else f'Modality {{g_idx}}'}}): {{o_val}}\")")
    
    # Inference
    usage_lines.append(f"{inner_indent}# Infer states")
    usage_lines.append(f"{inner_indent}qs_current = agent.infer_states(o_current)")
    
    # Print beliefs
    if print_beliefs:
        usage_lines.append(f"{inner_indent}if qs_current is not None:")
        usage_lines.append(f"{inner_indent}{indent}for f_idx, q_val in enumerate(qs_current):")
        usage_lines.append(f"{inner_indent}{indent}{indent}print(f\"Beliefs about {{state_names[f_idx] if state_names else f'Factor {{f_idx}}'}}: {{q_val}}\")")

    # Policy inference and action selection
    usage_lines.append("")
    usage_lines.append(f"{inner_indent}# Infer policies and sample action")
    usage_lines.append(f"{inner_indent}q_pi_current, efe_current = agent.infer_policies()")
    usage_lines.append(f"{inner_indent}if hasattr(agent, 'q_pi') and agent.q_pi is not None:")
    usage_lines.append(f"{inner_indent}{indent}print(f\"Posterior over policies (q_pi): {{agent.q_pi}}\")")
    usage_lines.append(f"{inner_indent}if efe_current is not None:")
    usage_lines.append(f"{inner_indent}{indent}print(f\"Expected Free Energy (EFE): {{efe_current}}\")")
    usage_lines.append(f"{inner_indent}action_agent = agent.sample_action()")
    
    # Map agent action to environment action
    usage_lines.append(f"{inner_indent}# Map agent's action (on control factors) to full environment action vector")
    usage_lines.append(f"{inner_indent}action_env = np.zeros(num_factors, dtype=int)")
    usage_lines.append(f"{inner_indent}if control_fac_idx and action_agent is not None:")
    usage_lines.append(f"{inner_indent}{indent}for i, cf_idx in enumerate(control_fac_idx):")
    usage_lines.append(f"{inner_indent}{indent}{indent}action_env[cf_idx] = int(action_agent[i])")

    # Print actions
    if print_actions:
        usage_lines.append(f"{inner_indent}# Construct action names for printing")
        usage_lines.append(f"{inner_indent}action_names_str_list = []")
        usage_lines.append(f"{inner_indent}if control_fac_idx and action_agent is not None:")
        usage_lines.append(f"{inner_indent}{indent}for i, cf_idx in enumerate(control_fac_idx):")
        usage_lines.append(f"{inner_indent}{indent}{indent}factor_action_name_list = agent.action_names.get(cf_idx, []) if hasattr(agent, 'action_names') and isinstance(agent.action_names, dict) else []")
        usage_lines.append(f"{inner_indent}{indent}{indent}action_idx_on_factor = int(action_agent[i])")
        usage_lines.append(f"{inner_indent}{indent}{indent}if factor_action_name_list and action_idx_on_factor < len(factor_action_name_list):")
        usage_lines.append(f"{inner_indent}{indent}{indent}{indent}action_names_str_list.append(f\"{{state_names[cf_idx] if state_names else f'Factor {{cf_idx}}'}}: {{factor_action_name_list[action_idx_on_factor]}} (idx {{action_idx_on_factor}})\")")
        usage_lines.append(f"{inner_indent}{indent}{indent}else:")
        usage_lines.append(f"{inner_indent}{indent}{indent}{indent}action_names_str_list.append(f\"{{state_names[cf_idx] if state_names else f'Factor {{cf_idx}}'}}: Action idx {{action_idx_on_factor}}\")")
        usage_lines.append(f"{inner_indent}print(f\"Action taken: {{', '.join(action_names_str_list) if action_names_str_list else 'No controllable actions or names not found'}}\")")

    # Update environment state
    usage_lines.append("")
    usage_lines.append(f"{inner_indent}# Update true states of the environment based on action")
    usage_lines.append(f"{inner_indent}s_next = np.zeros(num_factors, dtype=int)")
    usage_lines.append(f"{inner_indent}if s_current is not None and B_gen_process is not None:")
    usage_lines.append(f"{inner_indent}{indent}for f_idx in range(num_factors):")
    usage_lines.append(f"{inner_indent}{indent}{indent}# B_gen_process[f_idx] shape: (num_states[f_idx], num_states[f_idx], num_actions_for_this_factor_or_1)")
    usage_lines.append(f"{inner_indent}{indent}{indent}action_for_factor = action_env[f_idx] if f_idx in control_fac_idx else 0")
    usage_lines.append(f"{inner_indent}{indent}{indent}s_next[f_idx] = utils.sample(B_gen_process[f_idx][:, s_current[f_idx], action_for_factor])")
    usage_lines.append(f"{inner_indent}s_current = s_next.tolist()")

    # Print updated states
    if print_states:
        usage_lines.append(f"{inner_indent}if s_current is not None:")
        usage_lines.append(f"{inner_indent}{indent}for f_idx, s_val in enumerate(s_current):")
        usage_lines.append(f"{inner_indent}{indent}{indent}print(f\"New true state ({{state_names[f_idx] if state_names else f'Factor {{f_idx}}'}}): {{s_val}}\")")

    # Generate next observation
    usage_lines.append("")
    usage_lines.append(f"{inner_indent}# Generate next observation based on new true states")
    usage_lines.append(f"{inner_indent}o_next = np.zeros(num_modalities, dtype=int)")
    usage_lines.append(f"{inner_indent}if s_current is not None and A_gen_process is not None:")
    usage_lines.append(f"{inner_indent}{indent}for g_idx in range(num_modalities):")
    usage_lines.append(f"{inner_indent}{indent}{indent}# A_gen_process[g_idx] shape: (num_obs[g_idx], num_states[0], num_states[1], ...)")
    usage_lines.append(f"{inner_indent}{indent}{indent}# Construct index for A matrix: (outcome_idx, s_f0, s_f1, ...)")

    # This line needs special handling for variable number of factors
    if num_factors > 0:
        state_idx_part = ", ".join([f"s_current[{sf_i}]" for sf_i in range(num_factors)])
        usage_lines.append(f"{inner_indent}{indent}{indent}prob_vector = A_gen_process[g_idx][:, {state_idx_part}]")
    else:
        usage_lines.append(f"{inner_indent}{indent}{indent}# Warning: No hidden state factors defined")
        usage_lines.append(f"{inner_indent}{indent}{indent}prob_vector = A_gen_process[g_idx][:]")

    usage_lines.append(f"{inner_indent}{indent}{indent}o_next[g_idx] = utils.sample(prob_vector)")
    usage_lines.append(f"{inner_indent}o_current = o_next.tolist()")
    
    # Simulation conclusion
    usage_lines.append("")
    usage_lines.append(f"{indent}print(f\"\\nSimulation finished after {{T}} timesteps.\")")

    return usage_lines


def generate_placeholder_matrices(num_modalities: int, num_states: List[int]) -> Dict[str, List[str]]:
    """
    Generate functional matrix definitions for PyMDP based on GNN specifications.
    
    This function creates mathematically sound matrices that can be used for
    actual Active Inference simulations, rather than non-functional placeholders.
    
    Args:
        num_modalities: Number of observation modalities
        num_states: List of dimensions for each state factor
        
    Returns:
        Dictionary of code lines for different matrix definitions
    """
    matrix_defs = {
        "A": [],
        "B": [],
        "C": [],
        "D": []
    }
    
    # A matrix generation (likelihood mapping: observations -> states)
    if num_modalities > 0 and len(num_states) > 0:
        matrix_defs["A"].append("# A matrix: Likelihood mapping P(o|s) - observations given states")
        matrix_defs["A"].append("# Generated using softmax of random weights for functional simulation")
        matrix_defs["A"].append(f"A = utils.obj_array({num_modalities})")
        
        for i in range(num_modalities):
            # Create a functional likelihood matrix for each modality
            # Use softmax to ensure proper probability distributions
            matrix_defs["A"].append(f"# Modality {i} likelihood matrix")
            matrix_defs["A"].append(f"# Shape: (num_obs[{i}], {', '.join(str(n) for n in num_states)})")
            
            # Generate random weights and apply softmax for proper probabilities
            matrix_defs["A"].append(f"raw_weights_{i} = np.random.randn({max(1, num_states[0] if num_states else 1)}, {max(1, num_states[0] if num_states else 1)})")
            matrix_defs["A"].append(f"likelihood_{i} = utils.softmax(raw_weights_{i}, axis=0)")  # Normalize across states
            matrix_defs["A"].append(f"A[{i}] = likelihood_{i}")
    else:
        matrix_defs["A"].append("# No modalities or states defined - using minimal functional matrix")
        matrix_defs["A"].append("A = utils.obj_array(1)")
        matrix_defs["A"].append("A[0] = np.array([[0.8, 0.2], [0.2, 0.8]])  # 2x2 identity-like matrix")
        
    # B matrix generation (transition mapping: states -> states given actions)
    if len(num_states) > 0:
        matrix_defs["B"].append("# B matrix: Transition mapping P(s'|s,u) - next states given current states and actions")
        matrix_defs["B"].append("# Generated using identity-like transitions with small noise for exploration")
        matrix_defs["B"].append(f"B = utils.obj_array({len(num_states)})")
        
        for i, num_state in enumerate(num_states):
            # Create functional transition matrices for each state factor
            # Use identity-like matrices with small noise for realistic transitions
            matrix_defs["B"].append(f"# State factor {i} transition matrix")
            matrix_defs["B"].append(f"# Shape: ({num_state}, {num_state}, 2) - 2 actions for PyMDP compatibility")
            
            # Generate identity-like transition matrix with small noise
            matrix_defs["B"].append(f"identity_{i} = np.eye({num_state})")
            matrix_defs["B"].append(f"noise_{i} = np.random.uniform(0.05, 0.15, ({num_state}, {num_state}))")
            matrix_defs["B"].append(f"transition_base_{i} = identity_{i} + noise_{i}")
            matrix_defs["B"].append(f"transition_base_{i} = transition_base_{i} / np.sum(transition_base_{i}, axis=0, keepdims=True)")  # Normalize
            
            # Create action-dependent transitions (action 0: stay, action 1: move)
            matrix_defs["B"].append(f"B[{i}] = np.stack([transition_base_{i}, np.roll(transition_base_{i}, 1, axis=1)], axis=2)")
    else:
        matrix_defs["B"].append("# No state factors defined - using minimal functional transition matrix")
        matrix_defs["B"].append("B = utils.obj_array(1)")
        matrix_defs["B"].append("B[0] = np.array([[[0.9, 0.1], [0.1, 0.9]], [[0.1, 0.9], [0.9, 0.1]]])  # 2x2x2 transition matrix")
    
    # C vector generation (preferences over observations)
    if num_modalities > 0:
        matrix_defs["C"].append("# C vector: Preferences over observations (negative log likelihood)")
        matrix_defs["C"].append("# Generated with slight preference for certain observations")
        matrix_defs["C"].append(f"C = utils.obj_array({num_modalities})")
        
        for i in range(num_modalities):
            # Create preference vector for each modality
            # Use small negative values to indicate preferences
            matrix_defs["C"].append(f"# Modality {i} preferences")
            num_obs = max(1, num_states[0] if num_states else 1)
            matrix_defs["C"].append(f"preferences_{i} = np.random.uniform(-0.5, 0.5, {num_obs})")
            matrix_defs["C"].append(f"C[{i}] = preferences_{i}")
    else:
        matrix_defs["C"].append("# No modalities defined - using neutral preferences")
        matrix_defs["C"].append("C = utils.obj_array(1)")
        matrix_defs["C"].append("C[0] = np.array([0.0, 0.0])  # Neutral preferences")
    
    # D vector generation (initial beliefs over states)
    if len(num_states) > 0:
        matrix_defs["D"].append("# D vector: Initial beliefs over states (prior)")
        matrix_defs["D"].append("# Generated using uniform distribution for unbiased initialization")
        matrix_defs["D"].append(f"D = utils.obj_array({len(num_states)})")
        
        for i, num_state in enumerate(num_states):
            # Create initial belief vector for each state factor
            # Use uniform distribution for unbiased initialization
            matrix_defs["D"].append(f"# State factor {i} initial beliefs")
            matrix_defs["D"].append(f"initial_belief_{i} = np.ones({num_state}) / {num_state}  # Uniform prior")
            matrix_defs["D"].append(f"D[{i}] = initial_belief_{i}")
    else:
        matrix_defs["D"].append("# No state factors defined - using minimal initial beliefs")
        matrix_defs["D"].append("D = utils.obj_array(1)")
        matrix_defs["D"].append("D[0] = np.array([0.5, 0.5])  # Uniform initial beliefs")
        
    return matrix_defs 