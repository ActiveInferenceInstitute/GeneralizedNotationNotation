#!/usr/bin/env python3
"""
Execute Processor module for GNN Processing Pipeline.

This module provides execute processing capabilities for rendered implementations.
"""

from pathlib import Path
from typing import Dict, Any, List
import logging
import subprocess
import json
import os
import stat
from datetime import datetime

# Import logging helpers with fallback
try:
    from utils.pipeline_template import (
        log_step_start,
        log_step_success,
        log_step_error,
        log_step_warning
    )
except Exception:
    def log_step_start(logger, msg): logger.info(f"🚀 {msg}")
    def log_step_success(logger, msg): logger.info(f"✅ {msg}")
    def log_step_error(logger, msg): logger.error(f"❌ {msg}")
    def log_step_warning(logger, msg): logger.warning(f"⚠️ {msg}")

logger = logging.getLogger(__name__)

def process_execute(
    target_dir: Path,
    output_dir: Path,
    verbose: bool = False,
    **kwargs
) -> bool:
    """
    Execute rendered implementations from 11_render_output directory.
    
    This function searches for executable scripts generated by 11_render.py
    and executes them using subprocess, capturing their outputs and results.
    
    Args:
        target_dir: Directory containing rendered executable scripts (typically 11_render_output)
        output_dir: Directory to save execution results
        verbose: Enable verbose output
        **kwargs: Additional arguments
        
    Returns:
        True if processing successful, False otherwise
    """
    logger = logging.getLogger("execute")
    
    try:
        log_step_start(logger, "Processing execute - searching for rendered implementations")
        
        # Create results directory
        results_dir = output_dir / "execution_results"
        results_dir.mkdir(parents=True, exist_ok=True)
        
        # Initialize execution results
        execution_results = {
            "timestamp": datetime.now().isoformat(),
            "target_directory": str(target_dir),
            "output_directory": str(output_dir),
            "total_scripts_found": 0,
            "successful_executions": 0,
            "failed_executions": 0,
            "execution_details": [],
            "success": True
        }
        
        # Look for rendered implementations from 11_render_output
        if "11_render_output" in str(target_dir) or target_dir.name == "11_render_output":
            render_output_dir = target_dir
        else:
            # Look for 11_render_output in the typical location
            render_output_dir = target_dir.parent / "output" / "11_render_output"
            if not render_output_dir.exists():
                render_output_dir = target_dir / "11_render_output"
        
        if verbose:
            logger.info(f"Searching for executable scripts in: {render_output_dir}")
        
        if not render_output_dir.exists():
            log_step_warning(logger, f"Render output directory not found: {render_output_dir}")
            execution_results["success"] = True  # Not an error, just no files to execute
            execution_results["message"] = "No rendered implementations found"
        else:
            # Find executable scripts
            executable_scripts = find_executable_scripts(render_output_dir, verbose, logger)
            execution_results["total_scripts_found"] = len(executable_scripts)
            
            if not executable_scripts:
                log_step_warning(logger, "No executable scripts found in render output")
                execution_results["message"] = "No executable scripts found"
                execution_results["success"] = True
            else:
                logger.info(f"Found {len(executable_scripts)} executable scripts to run")
                
                # Execute each script
                for script_info in executable_scripts:
                    exec_result = execute_single_script(script_info, results_dir, verbose, logger)
                    execution_results["execution_details"].append(exec_result)
                    
                    if exec_result["success"]:
                        execution_results["successful_executions"] += 1
                    else:
                        execution_results["failed_executions"] += 1
        
        # Save detailed results
        results_file = results_dir / "execution_summary.json"
        with open(results_file, 'w') as f:
            json.dump(execution_results, f, indent=2, default=str)
            
        # Generate execution report
        generate_execution_report(execution_results, results_dir, logger)
        
        # Determine overall success
        if execution_results["failed_executions"] > 0:
            log_step_warning(logger, f"Execute processing completed with {execution_results['failed_executions']} failures")
            # Still return True as some scripts might have succeeded
        else:
            log_step_success(logger, "Execute processing completed successfully")
        
        return execution_results["success"]
        
    except Exception as e:
        log_step_error(logger, f"Execute processing failed: {e}")
        return False

def find_executable_scripts(render_output_dir: Path, verbose: bool, logger) -> List[Dict[str, Any]]:
    """
    Find executable scripts in the render output directory.
    
    Args:
        render_output_dir: Directory containing rendered scripts
        verbose: Enable verbose logging
        logger: Logger instance
        
    Returns:
        List of dictionaries with script information
    """
    executable_scripts = []
    
    # Define supported script types and their executors
    script_types = {
        '*.py': {'executor': 'python3', 'framework': 'python'},
        '*.jl': {'executor': 'julia', 'framework': 'julia'},
    }
    
    for pattern, config in script_types.items():
        scripts = list(render_output_dir.rglob(pattern))
        
        for script_path in scripts:
            # Skip test files and other non-executable scripts
            if any(skip in script_path.name.lower() for skip in ['test_', '__', 'readme']):
                continue
            
            # Check if script is executable or can be made executable
            script_info = {
                'path': script_path,
                'name': script_path.name,
                'framework': config['framework'],
                'executor': config['executor'],
                'relative_path': script_path.relative_to(render_output_dir),
                'size_bytes': script_path.stat().st_size if script_path.exists() else 0
            }
            
            executable_scripts.append(script_info)
            
            if verbose:
                logger.info(f"Found {config['framework']} script: {script_info['relative_path']}")
    
    return executable_scripts


def execute_single_script(script_info: Dict[str, Any], results_dir: Path, verbose: bool, logger) -> Dict[str, Any]:
    """
    Execute a single script using subprocess.
    
    Args:
        script_info: Dictionary containing script information
        results_dir: Directory to save execution results (will create implementation-specific subfolders)
        verbose: Enable verbose logging
        logger: Logger instance
        
    Returns:
        Dictionary with execution results
    """
    script_path = script_info['path']
    executor = script_info['executor']
    
    # Extract model name and framework from script path for organization
    # Expected path: .../11_render_output/model_name/framework/script.ext
    path_parts = script_path.parts
    if len(path_parts) >= 3:
        model_name = path_parts[-3]  # e.g., 'actinf_pomdp_agent' 
        framework = path_parts[-2]   # e.g., 'pymdp'
    else:
        model_name = 'unknown_model'
        framework = script_info['framework']
    
    # Prepare execution result
    exec_result = {
        'script_path': str(script_path),
        'script_name': script_info['name'],
        'framework': framework,
        'model_name': model_name,
        'executor': executor,
        'success': False,
        'return_code': None,
        'stdout': '',
        'stderr': '',
        'execution_time': 0,
        'timestamp': datetime.now().isoformat()
    }
    
    try:
        if verbose:
            logger.info(f"Executing {script_info['framework']} script: {script_info['name']}")
        
        start_time = datetime.now()
        
        # Check if the executor is available
        try:
            subprocess.run([executor, '--version'], 
                         capture_output=True, 
                         text=True, 
                         timeout=5,
                         check=True)
        except (subprocess.CalledProcessError, FileNotFoundError, subprocess.TimeoutExpired):
            exec_result['error'] = f"Executor '{executor}' is not available or not working"
            logger.warning(f"Executor '{executor}' is not available - skipping {script_info['name']}")
            return exec_result
        
        # Execute the script
        # Use the script name only since we're running from its directory
        script_name = script_path.name
        result = subprocess.run(
            [executor, script_name],
            capture_output=True,
            text=True,
            timeout=300,  # 5 minute timeout
            cwd=script_path.parent  # Run in the script's directory
        )
        
        end_time = datetime.now()
        exec_result['execution_time'] = (end_time - start_time).total_seconds()
        exec_result['return_code'] = result.returncode
        exec_result['stdout'] = result.stdout
        exec_result['stderr'] = result.stderr
        
        if result.returncode == 0:
            exec_result['success'] = True
            logger.info(f"✅ Successfully executed {script_info['name']}")
            if verbose and result.stdout:
                logger.info(f"Script output: {result.stdout[:200]}...")  # Show first 200 chars
        else:
            logger.error(f"❌ Script {script_info['name']} failed with return code {result.returncode}")
            if result.stderr:
                logger.error(f"Error output: {result.stderr[:200]}...")  # Show first 200 chars
                
        # Save individual script output in implementation-specific subdirectory
        # Create the implementation-specific directory structure
        impl_specific_dir = results_dir.parent / model_name / framework / "execution_logs"
        impl_specific_dir.mkdir(parents=True, exist_ok=True)
        
        # Also create other expected subdirectories for this framework
        if framework == "pymdp":
            (results_dir.parent / model_name / framework / "simulation_data").mkdir(parents=True, exist_ok=True)
            (results_dir.parent / model_name / framework / "traces").mkdir(parents=True, exist_ok=True)
            (results_dir.parent / model_name / framework / "visualizations").mkdir(parents=True, exist_ok=True)
        elif framework == "discopy":
            (results_dir.parent / model_name / framework / "diagram_outputs").mkdir(parents=True, exist_ok=True)
            (results_dir.parent / model_name / framework / "analysis").mkdir(parents=True, exist_ok=True)
            (results_dir.parent / model_name / framework / "visualizations").mkdir(parents=True, exist_ok=True)
        elif framework == "activeinference_jl":
            (results_dir.parent / model_name / framework / "simulation_data").mkdir(parents=True, exist_ok=True)
            (results_dir.parent / model_name / framework / "free_energy_traces").mkdir(parents=True, exist_ok=True)
            (results_dir.parent / model_name / framework / "visualizations").mkdir(parents=True, exist_ok=True)
        elif framework == "rxinfer":
            (results_dir.parent / model_name / framework / "inference_data").mkdir(parents=True, exist_ok=True)
            (results_dir.parent / model_name / framework / "posterior_traces").mkdir(parents=True, exist_ok=True)
            (results_dir.parent / model_name / framework / "visualizations").mkdir(parents=True, exist_ok=True)
        
        output_file = impl_specific_dir / f"{script_info['name']}_execution.log"
        with open(output_file, 'w') as f:
            f.write(f"Execution Results for {script_info['name']}\n")
            f.write(f"Timestamp: {exec_result['timestamp']}\n")
            f.write(f"Return Code: {result.returncode}\n")
            f.write(f"Execution Time: {exec_result['execution_time']:.2f} seconds\n")
            f.write(f"Model: {model_name}\n")
            f.write(f"Framework: {framework}\n")
            f.write(f"Output Directory: {impl_specific_dir.parent}\n\n")
            f.write("STDOUT:\n")
            f.write(result.stdout)
            f.write("\n\nSTDERR:\n")
            f.write(result.stderr)
            
        # Also save to centralized location for backward compatibility
        script_output_dir = results_dir / 'individual_outputs' / framework
        script_output_dir.mkdir(parents=True, exist_ok=True)
        
        centralized_output = script_output_dir / f"{script_info['name']}_output.txt"
        with open(centralized_output, 'w') as f:
            f.write(f"Execution Results for {script_info['name']}\n")
            f.write(f"Timestamp: {exec_result['timestamp']}\n")
            f.write(f"Return Code: {result.returncode}\n")
            f.write(f"Execution Time: {exec_result['execution_time']:.2f} seconds\n\n")
            f.write("STDOUT:\n")
            f.write(result.stdout)
            f.write("\n\nSTDERR:\n")
            f.write(result.stderr)
            
        exec_result['output_file'] = str(output_file)
        exec_result['centralized_output_file'] = str(centralized_output)
        exec_result['implementation_directory'] = str(impl_specific_dir.parent)
        
    except subprocess.TimeoutExpired:
        exec_result['error'] = 'Script execution timed out (5 minutes)'
        logger.error(f"Script {script_info['name']} timed out")
        
    except Exception as e:
        exec_result['error'] = str(e)
        exec_result['error_type'] = type(e).__name__
        logger.error(f"Error executing {script_info['name']}: {e}")
    
    return exec_result


def generate_execution_report(execution_results: Dict[str, Any], results_dir: Path, logger):
    """
    Generate a comprehensive execution report.
    
    Args:
        execution_results: Dictionary with execution results
        results_dir: Directory to save the report
        logger: Logger instance
    """
    report_file = results_dir / "execution_report.md"
    
    try:
        with open(report_file, 'w') as f:
            f.write("# GNN Script Execution Report\n\n")
            f.write(f"**Generated:** {execution_results['timestamp']}\n")
            f.write(f"**Target Directory:** {execution_results['target_directory']}\n")
            f.write(f"**Output Directory:** {execution_results['output_directory']}\n\n")
            
            f.write("## Summary\n\n")
            f.write(f"- **Total Scripts Found:** {execution_results['total_scripts_found']}\n")
            f.write(f"- **Successful Executions:** {execution_results['successful_executions']}\n")
            f.write(f"- **Failed Executions:** {execution_results['failed_executions']}\n\n")
            
            if execution_results['execution_details']:
                f.write("## Execution Details\n\n")
                
                for detail in execution_results['execution_details']:
                    status = "✅ SUCCESS" if detail['success'] else "❌ FAILED"
                    f.write(f"### {detail['script_name']} - {status}\n\n")
                    f.write(f"- **Framework:** {detail['framework']}\n")
                    f.write(f"- **Executor:** {detail['executor']}\n")
                    f.write(f"- **Path:** `{detail['script_path']}`\n")
                    f.write(f"- **Return Code:** {detail.get('return_code', 'N/A')}\n")
                    f.write(f"- **Execution Time:** {detail.get('execution_time', 0):.2f} seconds\n")
                    
                    if not detail['success'] and 'error' in detail:
                        f.write(f"- **Error:** {detail['error']}\n")
                    
                    if 'output_file' in detail:
                        f.write(f"- **Detailed Output:** {detail['output_file']}\n")
                    
                    f.write("\n")
            
            f.write("## Next Steps\n\n")
            if execution_results['failed_executions'] > 0:
                f.write("1. Review failed executions above\n")
                f.write("2. Check individual output files for detailed error information\n")
                f.write("3. Ensure required dependencies are installed\n")
                f.write("4. Verify script syntax and functionality\n\n")
            else:
                f.write("All scripts executed successfully! Check individual output files for results.\n\n")
            
        logger.info(f"Generated execution report: {report_file}")
        
    except Exception as e:
        logger.error(f"Failed to generate execution report: {e}")


def execute_simulation_from_gnn(gnn_file: Path, output_dir: Path) -> Dict[str, Any]:
    """
    Execute simulation from GNN file.
    
    Args:
        gnn_file: Path to GNN file
        output_dir: Output directory
        
    Returns:
        Dictionary with execution results
    """
    try:
        logger.info(f"Executing simulation for {gnn_file}")
        
        # Import execution engine
        from .executor import ExecutionEngine
        
        # Create execution engine
        engine = ExecutionEngine()
        
        # Execute simulation
        result = engine.execute_simulation_from_gnn(gnn_file, output_dir)
        
        return result
        
    except Exception as e:
        logger.error(f"Failed to execute simulation for {gnn_file}: {e}")
        return {
            "success": False,
            "error": str(e)
        }
