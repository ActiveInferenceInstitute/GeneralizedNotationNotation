#!/usr/bin/env python3
"""
DisCoPy execution module for the GNN Processing Pipeline.

This module provides functions to validate and analyze DisCoPy diagrams
that were generated by the GNN rendering step (9_render.py).
"""

import logging
import os
import json
from pathlib import Path
from typing import List, Optional, Union, Dict, Any, Tuple

logger = logging.getLogger(__name__)

# Import DisCoPy functionality
try:
    from ..discopy_translator_module.translator import (
        JAX_FULLY_OPERATIONAL,
        MATPLOTLIB_AVAILABLE,
        gnn_file_to_discopy_diagram,
        gnn_file_to_discopy_matrix_diagram
    )
    from ..discopy_translator_module.visualize_jax_output import plot_tensor_output
    DISCOPY_AVAILABLE = True
except ImportError as e:
    logger.warning(f"DisCoPy translator module not available: {e}")
    JAX_FULLY_OPERATIONAL = False
    MATPLOTLIB_AVAILABLE = False
    gnn_file_to_discopy_diagram = None
    gnn_file_to_discopy_matrix_diagram = None
    plot_tensor_output = None
    DISCOPY_AVAILABLE = False


class DisCoPyExecutor:
    """
    DisCoPy Executor for validating and analyzing rendered DisCoPy diagrams.
    """
    
    def __init__(self, verbose: bool = False):
        """
        Initialize the DisCoPy executor.
        
        Args:
            verbose: Enable verbose logging
        """
        self.verbose = verbose
        if verbose:
            logger.setLevel(logging.DEBUG)
    
    def validate_diagram(self, diagram_path: Path) -> Tuple[bool, str]:
        """
        Validate that a DisCoPy diagram file exists and is accessible.
        
        Args:
            diagram_path: Path to the diagram file
            
        Returns:
            Tuple of (success: bool, message: str)
        """
        if not diagram_path.exists():
            return False, f"Diagram file not found: {diagram_path}"
        
        if diagram_path.suffix.lower() not in ['.png', '.jpg', '.jpeg', '.svg']:
            return False, f"Unexpected diagram file format: {diagram_path.suffix}"
        
        try:
            # Check if the file is readable and has content
            file_size = diagram_path.stat().st_size
            if file_size == 0:
                return False, f"Diagram file is empty: {diagram_path}"
            
            logger.debug(f"Validated diagram file: {diagram_path} ({file_size} bytes)")
            return True, f"Diagram file validated successfully"
            
        except Exception as e:
            return False, f"Error validating diagram file: {e}"
    
    def analyze_jax_output(self, jax_output_path: Path) -> Tuple[bool, str, Dict[str, Any]]:
        """
        Analyze a JAX evaluation output file.
        
        Args:
            jax_output_path: Path to the JAX evaluation output
            
        Returns:
            Tuple of (success: bool, message: str, analysis: Dict)
        """
        if not jax_output_path.exists():
            return False, f"JAX output file not found: {jax_output_path}", {}
        
        analysis = {
            "file_path": str(jax_output_path),
            "file_size_bytes": 0,
            "file_type": jax_output_path.suffix.lower(),
            "validation_status": "unknown"
        }
        
        try:
            file_size = jax_output_path.stat().st_size
            analysis["file_size_bytes"] = file_size
            
            if file_size == 0:
                analysis["validation_status"] = "empty"
                return False, f"JAX output file is empty: {jax_output_path}", analysis
            
            # For image files, just validate they exist and have content
            if jax_output_path.suffix.lower() in ['.png', '.jpg', '.jpeg']:
                analysis["validation_status"] = "valid_image"
                return True, f"JAX output image validated successfully", analysis
            
            # For other files, try to read and analyze content
            analysis["validation_status"] = "valid_file"
            logger.debug(f"Analyzed JAX output: {jax_output_path} ({file_size} bytes)")
            return True, f"JAX output file analyzed successfully", analysis
            
        except Exception as e:
            analysis["validation_status"] = "error"
            analysis["error"] = str(e)
            return False, f"Error analyzing JAX output: {e}", analysis
    
    def execute_directory(self, target_dir: Path, output_dir: Path) -> Dict[str, Any]:
        """
        Execute validation and analysis on all DisCoPy outputs in a directory.
        
        Args:
            target_dir: Directory containing rendered DisCoPy outputs
            output_dir: Directory for execution results
            
        Returns:
            Dictionary with execution results
        """
        results = {
            "executions": [],
            "successes": 0,
            "failures": 0,
            "analysis_summary": {
                "diagrams_validated": 0,
                "jax_outputs_analyzed": 0,
                "total_files_processed": 0
            }
        }
        
        if not target_dir.exists():
            logger.warning(f"Target directory does not exist: {target_dir}")
            return results
        
        # Create output directory
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Find DisCoPy diagram files
        diagram_files = []
        jax_files = []
        
        # Look for common DisCoPy output patterns
        for pattern in ["*_diagram.png", "*_diagram.jpg", "*_diagram.svg"]:
            diagram_files.extend(target_dir.glob(f"**/{pattern}"))
        
        for pattern in ["*_jax_evaluation.png", "*_jax_evaluation.jpg", "*_evaluation*.png"]:
            jax_files.extend(target_dir.glob(f"**/{pattern}"))
        
        logger.info(f"Found {len(diagram_files)} diagram files and {len(jax_files)} JAX output files")
        
        # Validate diagram files
        for diagram_file in diagram_files:
            try:
                success, message = self.validate_diagram(diagram_file)
                
                execution_result = {
                    "script": diagram_file.name,
                    "type": "diagram_validation",
                    "status": "SUCCESS" if success else "FAILED",
                    "message": message,
                    "file_path": str(diagram_file)
                }
                
                results["executions"].append(execution_result)
                
                if success:
                    results["successes"] += 1
                    results["analysis_summary"]["diagrams_validated"] += 1
                else:
                    results["failures"] += 1
                
                results["analysis_summary"]["total_files_processed"] += 1
                
            except Exception as e:
                logger.error(f"Error processing diagram {diagram_file}: {e}")
                results["failures"] += 1
                results["executions"].append({
                    "script": diagram_file.name,
                    "type": "diagram_validation",
                    "status": "ERROR",
                    "message": str(e),
                    "file_path": str(diagram_file)
                })
        
        # Analyze JAX output files
        for jax_file in jax_files:
            try:
                success, message, analysis = self.analyze_jax_output(jax_file)
                
                execution_result = {
                    "script": jax_file.name,
                    "type": "jax_analysis",
                    "status": "SUCCESS" if success else "FAILED",
                    "message": message,
                    "file_path": str(jax_file),
                    "analysis": analysis
                }
                
                results["executions"].append(execution_result)
                
                if success:
                    results["successes"] += 1
                    results["analysis_summary"]["jax_outputs_analyzed"] += 1
                else:
                    results["failures"] += 1
                
                results["analysis_summary"]["total_files_processed"] += 1
                
            except Exception as e:
                logger.error(f"Error processing JAX output {jax_file}: {e}")
                results["failures"] += 1
                results["executions"].append({
                    "script": jax_file.name,
                    "type": "jax_analysis",
                    "status": "ERROR",
                    "message": str(e),
                    "file_path": str(jax_file)
                })
        
        # Save execution report
        report_file = output_dir / "discopy_execution_report.json"
        try:
            with open(report_file, 'w') as f:
                json.dump(results, f, indent=2)
            logger.info(f"DisCoPy execution report saved to: {report_file}")
        except Exception as e:
            logger.error(f"Failed to save execution report: {e}")
        
        return results


def run_discopy_analysis(
    pipeline_output_dir: Union[str, Path],
    execution_output_dir: Optional[Union[str, Path]] = None,
    recursive_search: bool = True,
    verbose: bool = False
) -> bool:
    """
    Find and analyze all DisCoPy outputs in the designated output directory.
    
    Args:
        pipeline_output_dir: Main pipeline output directory
        execution_output_dir: Specific directory for DisCoPy execution outputs (optional)
        recursive_search: Whether to search recursively for outputs
        verbose: Whether to enable verbose output
        
    Returns:
        bool: True if analysis completed successfully, False if any failed
    """
    # Set up execution output directory
    if execution_output_dir:
        exec_output_dir = Path(execution_output_dir)
        exec_output_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f"DisCoPy execution outputs will be saved to: {exec_output_dir}")
        results_dir = exec_output_dir
    else:
        results_dir = Path(pipeline_output_dir) / "execution_results" / "discopy_results"
    
    # Construct the path to the DisCoPy outputs
    discopy_dir = Path(pipeline_output_dir) / "gnn_rendered_simulators" / "discopy"
    
    logger.info(f"Looking for DisCoPy outputs in: {discopy_dir}")
    
    if not discopy_dir.exists():
        logger.info("No DisCoPy output directory found")
        return True  # Not an error, just nothing to do
    
    # Create executor and run analysis
    executor = DisCoPyExecutor(verbose=verbose)
    results = executor.execute_directory(discopy_dir, results_dir)
    
    # Report analysis results
    total_processed = results["analysis_summary"]["total_files_processed"]
    successes = results["successes"]
    failures = results["failures"]
    
    logger.info(f"DisCoPy analysis summary: {successes} succeeded, {failures} failed, {total_processed} total")
    
    # Consider the overall run successful if any files were processed successfully
    return failures == 0 or successes > 0


if __name__ == "__main__":
    # Setup logging for standalone execution
    import sys
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        stream=sys.stdout
    )
    
    # Parse command-line arguments for standalone execution
    import argparse
    parser = argparse.ArgumentParser(description="Analyze DisCoPy outputs generated by the GNN rendering step")
    parser.add_argument("--output-dir", type=Path, default="../output",
                       help="Main pipeline output directory")
    parser.add_argument("--recursive", action=argparse.BooleanOptionalAction, default=True,
                       help="Recursively search for outputs in the output directory")
    parser.add_argument("--verbose", action=argparse.BooleanOptionalAction, default=False,
                       help="Enable verbose output")
    
    args = parser.parse_args()
    
    # Enable verbose logging if requested
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    # Run the analysis
    success = run_discopy_analysis(
        pipeline_output_dir=args.output_dir,
        recursive_search=args.recursive,
        verbose=args.verbose
    )
    
    # Exit with appropriate status code
    sys.exit(0 if success else 1) 