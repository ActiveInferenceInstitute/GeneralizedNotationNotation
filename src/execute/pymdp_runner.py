"""
PyMDP Runner for GNN Pipeline

This script finds and executes PyMDP scripts generated by the GNN pipeline (typically by 9_render.py).
It expects these scripts to be located in a subdirectory of the main pipeline's output directory,
conventionally: <pipeline_output_dir>/gnn_rendered_simulators/pymdp/
"""

import subprocess
import sys
from pathlib import Path
import logging
import os

logger = logging.getLogger(__name__) # Will be child of GNN_Pipeline logger if run by main

def run_pymdp_scripts(pipeline_output_dir: str, recursive_search: bool, verbose: bool) -> bool:
    """
    Finds and executes all .py files in the PyMDP rendered scripts directory.

    Args:
        pipeline_output_dir: The root output directory of the GNN pipeline.
        recursive_search: Whether to search for PyMDP scripts recursively in their base directory.
        verbose: If True, sets subprocess output to be more verbose.

    Returns:
        True if all found scripts executed successfully, False otherwise.
    """
    rendered_pymdp_base_dir = Path(pipeline_output_dir).resolve() / "gnn_rendered_simulators" / "pymdp"

    logger.info(f"Searching for PyMDP scripts to execute in: {rendered_pymdp_base_dir}")
    if not rendered_pymdp_base_dir.is_dir():
        logger.warning(f"PyMDP rendered scripts directory not found: {rendered_pymdp_base_dir}")
        logger.warning("This might be expected if no PyMDP models were rendered in step 9.")
        return True # Not a failure of this step, just no scripts to run.

    glob_pattern = "**/*.py" if recursive_search else "*.py"
    pymdp_scripts = list(rendered_pymdp_base_dir.glob(glob_pattern))

    if not pymdp_scripts:
        logger.info(f"No PyMDP scripts (matching '{glob_pattern}') found in {rendered_pymdp_base_dir}.")
        return True # No scripts to run is not an error for this runner.

    logger.info(f"Found {len(pymdp_scripts)} PyMDP script(s) to execute.")

    all_executions_successful = True
    overall_summary = []

    # Determine the python executable to use (prefer venv if available)
    python_executable = sys.executable # Default to current Python
    project_root = Path(__file__).resolve().parent.parent # src/
    venv_python = project_root / ".venv" / "bin" / "python"
    if venv_python.exists():
        python_executable = str(venv_python)
        logger.info(f"Using Python executable from virtual environment: {python_executable}")
    else:
        logger.info(f"Using system Python executable: {python_executable}")

    for script_path in pymdp_scripts:
        logger.info(f"  Executing PyMDP script: {script_path.relative_to(rendered_pymdp_base_dir.parent.parent)}")
        try:
            # Scripts are run with their own directory as CWD to handle relative paths within the script if any.
            run_cwd = script_path.parent
            env = os.environ.copy()
            # If scripts need access to modules in src or src/.venv, PYTHONPATH might need adjustment
            # For now, assume they are self-contained or use stdlib/pymdp from the venv python

            process = subprocess.run(
                [python_executable, str(script_path.name)],
                capture_output=True,
                text=True,
                check=False, # Don't raise exception on non-zero exit, we handle it
                cwd=run_cwd,
                env=env
            )

            if process.returncode == 0:
                logger.info(f"    ✅ Execution successful for: {script_path.name}")
                if verbose and process.stdout:
                    logger.debug(f"      Output:\n{process.stdout}")
                overall_summary.append((str(script_path.name), "Success", process.stdout if process.stdout else "No output"))
            else:
                all_executions_successful = False
                logger.error(f"    ❌ Execution FAILED for: {script_path.name} (Exit code: {process.returncode})")
                if process.stdout:
                    logger.error(f"      Stdout:\n{process.stdout}")
                if process.stderr:
                    logger.error(f"      Stderr:\n{process.stderr}")
                overall_summary.append((str(script_path.name), f"Failed (code {process.returncode})", process.stdout + process.stderr))
        except Exception as e:
            all_executions_successful = False
            logger.error(f"    ❌ Exception during execution of {script_path.name}: {e}", exc_info=verbose)
            overall_summary.append((str(script_path.name), "Exception", str(e)))

    logger.info("--- PyMDP Execution Summary ---")
    for name, status, output_preview in overall_summary:
        log_func = logger.info if status == "Success" else logger.warning
        log_func(f"  - {name}: {status}")
        if verbose and output_preview.strip() and status == "Success":
            logger.debug(f"    Output Preview (first 200 chars):\n{output_preview.strip()[:200]}...")
        elif status != "Success" and output_preview.strip():
            logger.warning(f"    Output/Error (first 500 chars):\n{output_preview.strip()[:500]}...")

    return all_executions_successful

if __name__ == '__main__':
    # This block is for testing pymdp_runner.py directly.
    # It requires the GNN pipeline to have run up to step 9 (render)
    # and produced some PyMDP scripts in the expected output location.

    # Setup basic logging for standalone run
    logging.basicConfig(
        level=logging.DEBUG, # Show debug for standalone test
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    # Determine project root assuming this script is in src/execute/
    # and output is in <project_root>/output/
    project_root_dir = Path(__file__).resolve().parent.parent.parent
    test_output_dir = project_root_dir / "output"

    logger.info(f"Standalone Test: Running PyMDP scripts from output directory: {test_output_dir}")
    success = run_pymdp_scripts(
        pipeline_output_dir=str(test_output_dir),
        recursive_search=True, # Typically rendered scripts might be in subdirs
        verbose=True
    )

    if success:
        logger.info("Standalone Test: All PyMDP scripts executed successfully.")
        sys.exit(0)
    else:
        logger.error("Standalone Test: Some PyMDP scripts failed to execute.")
        sys.exit(1) 