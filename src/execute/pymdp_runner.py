"""
PyMDP Runner for GNN Pipeline

This script finds and executes PyMDP scripts generated by the GNN pipeline (typically by 9_render.py).
It expects these scripts to be located in a subdirectory of the main pipeline's output directory,
conventionally: <pipeline_output_dir>/gnn_rendered_simulators/pymdp/
"""

import subprocess
import sys
from pathlib import Path
import logging
import os

logger = logging.getLogger(__name__) # Will be child of GNN_Pipeline logger if run by main

def run_pymdp_scripts(pipeline_output_dir: str, recursive_search: bool, verbose: bool) -> bool:
    """
    Finds and executes all .py files in the PyMDP rendered scripts directory.
    Logs stdout/stderr for each script to a dedicated log directory.

    Args:
        pipeline_output_dir: The root output directory of the GNN pipeline.
        recursive_search: Whether to search for PyMDP scripts recursively in their base directory.
        verbose: If True, sets subprocess output to be more verbose.

    Returns:
        True if all found scripts executed successfully, False otherwise.
    """
    pipeline_output_path = Path(pipeline_output_dir).resolve()
    rendered_pymdp_base_dir = pipeline_output_path / "gnn_rendered_simulators" / "pymdp"
    
    # Define base directory for execution logs from this step
    step_10_log_dir_base = pipeline_output_path / "pymdp_execute_logs"
    try:
        step_10_log_dir_base.mkdir(parents=True, exist_ok=True)
        logger.info(f"Execution logs for Step 10 will be stored in: {step_10_log_dir_base}")
    except OSError as e:
        logger.error(f"Could not create base log directory {step_10_log_dir_base}: {e}")
        # Proceeding without dedicated file logs if base dir creation fails, but log an error.
        # Alternatively, could return False here. For now, attempt to continue.

    logger.info(f"Searching for PyMDP scripts to execute in: {rendered_pymdp_base_dir}")
    if not rendered_pymdp_base_dir.is_dir():
        logger.warning(f"PyMDP rendered scripts directory not found: {rendered_pymdp_base_dir}")
        logger.warning("This might be expected if no PyMDP models were rendered in step 9.")
        return True # Not a failure of this step, just no scripts to run.

    glob_pattern = "**/*.py" if recursive_search else "*.py"
    pymdp_scripts = list(rendered_pymdp_base_dir.glob(glob_pattern))

    if not pymdp_scripts:
        logger.info(f"No PyMDP scripts (matching '{glob_pattern}') found in {rendered_pymdp_base_dir}.")
        return True # No scripts to run is not an error for this runner.

    logger.info(f"Found {len(pymdp_scripts)} PyMDP script(s) to execute.")

    all_executions_successful = True
    overall_summary = []

    # Determine the python executable to use (prefer venv if available)
    python_executable = sys.executable # Default to current Python
    project_root = Path(__file__).resolve().parent.parent # src/
    venv_python = project_root / ".venv" / "bin" / "python"
    if venv_python.exists():
        python_executable = str(venv_python)
        logger.info(f"Using Python executable from virtual environment: {python_executable}")
    else:
        logger.info(f"Using system Python executable: {python_executable}")

    for script_path in pymdp_scripts:
        script_stem = script_path.stem
        script_log_dir = step_10_log_dir_base / script_stem
        try:
            script_log_dir.mkdir(parents=True, exist_ok=True)
        except OSError as e:
            logger.error(f"Could not create log directory {script_log_dir} for {script_path.name}: {e}. Logs will not be saved to files for this script.")
            # Fallback: don't use script_log_dir for this script if creation fails
            current_script_log_dir = None 
        else:
            current_script_log_dir = script_log_dir

        logger.info(f"  Executing PyMDP script: {script_path.relative_to(pipeline_output_path)}")
        stdout_path = current_script_log_dir / "stdout.log" if current_script_log_dir else None
        stderr_path = current_script_log_dir / "stderr.log" if current_script_log_dir else None
        log_file_info = f" (Logs: {current_script_log_dir})" if current_script_log_dir else " (File logging disabled due to dir error)"

        try:
            # Scripts are run with their own directory as CWD to handle relative paths within the script if any.
            run_cwd = script_path.parent
            env = os.environ.copy()
            # Ensure PYTHONPATH includes project root and venv site-packages for consistency
            project_root_str = str(project_root)
            venv_site_packages_path = str(project_root / ".venv" / "lib" / f"python{sys.version_info.major}.{sys.version_info.minor}" / "site-packages")
            
            current_python_path = env.get("PYTHONPATH", "")
            path_parts = {project_root_str, venv_site_packages_path}
            if current_python_path:
                path_parts.update(current_python_path.split(os.pathsep))
            
            env["PYTHONPATH"] = os.pathsep.join(sorted(list(path_parts)))

            if verbose:
                logger.debug(f"      Using PYTHONPATH for subprocess: {env['PYTHONPATH']}")

            process = subprocess.run(
                [python_executable, str(script_path.name)],
                capture_output=True,
                text=True,
                check=False, # Don't raise exception on non-zero exit, we handle it
                cwd=run_cwd,
                env=env
            )

            # Save stdout and stderr to files
            if current_script_log_dir:
                try:
                    with open(stdout_path, 'w') as f_out:
                        f_out.write(process.stdout if process.stdout else "")
                    logger.debug(f"      Stdout successfully written to {stdout_path}")
                except OSError as e:
                    logger.error(f"    Error writing stdout log to {stdout_path} for {script_path.name}: {e}")
                try:
                    with open(stderr_path, 'w') as f_err:
                        f_err.write(process.stderr if process.stderr else "")
                    logger.debug(f"      Stderr successfully written to {stderr_path}")
                except OSError as e:
                    logger.error(f"    Error writing stderr log to {stderr_path} for {script_path.name}: {e}")

            if process.returncode == 0:
                logger.info(f"    ✅ Execution successful for: {script_path.name}{log_file_info}")
                if verbose and process.stdout and process.stdout.strip(): # Still log to console if verbose and stdout has content
                    logger.debug(f"      Output (also in {stdout_path}):\\n{process.stdout.strip()}")
                overall_summary.append((str(script_path.name), "Success", process.stdout if process.stdout else "No output", str(current_script_log_dir if current_script_log_dir else "N/A")))
            else:
                all_executions_successful = False
                logger.error(f"    ❌ Execution FAILED for: {script_path.name} (Exit code: {process.returncode}){log_file_info}")
                if process.stdout and process.stdout.strip():
                    logger.error(f"      Stdout content for failed script (see full log in {stdout_path}). Preview:\\n{process.stdout.strip()[:500]}...")
                else:
                    logger.error(f"      No stdout content for failed script (Full log: {stdout_path}).")
                if process.stderr and process.stderr.strip():
                    logger.error(f"      Stderr content (see full log in {stderr_path}):\\n{process.stderr.strip()}")
                else:
                    logger.error(f"      No stderr content for failed script (Full log: {stderr_path}).")

                full_output_for_summary = (process.stdout if process.stdout else "") + (process.stderr if process.stderr else "")
                overall_summary.append((str(script_path.name), f"Failed (code {process.returncode})", full_output_for_summary, str(current_script_log_dir if current_script_log_dir else "N/A")))
        except Exception as e:
            all_executions_successful = False
            logger.error(f"    ❌ Exception during execution of {script_path.name}: {e}{log_file_info}", exc_info=verbose)
            if current_script_log_dir: # Attempt to save exception to a file too
                try:
                    with open(current_script_log_dir / "exception.log", 'w') as f_exc:
                        import traceback
                        f_exc.write(f"Exception: {e}\n")
                        f_exc.write(traceback.format_exc())
                except OSError as e_write:
                    logger.error(f"    Could not write exception log for {script_path.name}: {e_write}")
            overall_summary.append((str(script_path.name), "Exception", str(e), str(current_script_log_dir if current_script_log_dir else "N/A")))

    logger.info("--- PyMDP Execution Summary ---")
    for name, status, output_preview, log_dir_path_str in overall_summary:
        log_func = logger.info if status == "Success" else logger.warning
        log_func(f"  - Script: {name}")
        log_func(f"    Status: {status}")
        log_func(f"    Log Dir: {log_dir_path_str}")
        
        # Limit console output preview, direct users to log files
        if status == "Success":
            if verbose and output_preview.strip():
                 logger.debug(f"    Console Output Preview (see stdout.log for full):\n{output_preview.strip()[:200]}...")
        else: # Failed or Exception
            if output_preview.strip():
                logger.warning(f"    Console Output/Error Preview (see .log files for full):\n{output_preview.strip()[:500]}...")
            if status == "Exception" and not output_preview.strip(): # If exception had no direct stdout/stderr
                 logger.warning(f"    Exception details logged to exception.log in the log directory.")


    return all_executions_successful

if __name__ == '__main__':
    # This block is for testing pymdp_runner.py directly.
    # It requires the GNN pipeline to have run up to step 9 (render)
    # and produced some PyMDP scripts in the expected output location.

    # Setup basic logging for standalone run
    logging.basicConfig(
        level=logging.DEBUG, # Show debug for standalone test
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    # Determine project root assuming this script is in src/execute/
    # and output is in <project_root>/output/
    project_root_dir = Path(__file__).resolve().parent.parent.parent
    test_output_dir = project_root_dir / "output"

    logger.info(f"Standalone Test: Running PyMDP scripts from output directory: {test_output_dir}")
    success = run_pymdp_scripts(
        pipeline_output_dir=str(test_output_dir),
        recursive_search=True, # Typically rendered scripts might be in subdirs
        verbose=True
    )

    if success:
        logger.info("Standalone Test: All PyMDP scripts executed successfully.")
        sys.exit(0)
    else:
        logger.error("Standalone Test: Some PyMDP scripts failed to execute.")
        sys.exit(1) 