"""
PyMDP Runner for GNN Pipeline

This script finds and executes PyMDP scripts generated by the GNN pipeline (typically by 9_render.py).
It expects these scripts to be located in a subdirectory of the main pipeline's output directory,
conventionally: <pipeline_output_dir>/gnn_rendered_simulators/pymdp/
"""

import subprocess
import sys
from pathlib import Path
import logging
import os

logger = logging.getLogger(__name__) # Will be child of GNN_Pipeline logger if run by main

def run_pymdp_scripts(pipeline_output_dir: str, recursive_search: bool, verbose: bool) -> bool:
    """
    Finds and executes all .py files in the PyMDP rendered scripts directory.
    Logs stdout/stderr for each script to a dedicated log directory.

    Args:
        pipeline_output_dir: The root output directory of the GNN pipeline.
        recursive_search: Whether to search for PyMDP scripts recursively in their base directory.
        verbose: If True, sets subprocess output to be more verbose.

    Returns:
        True if all found scripts executed successfully, False otherwise.
    """
    pipeline_output_path = Path(pipeline_output_dir).resolve()
    rendered_pymdp_base_dir = pipeline_output_path / "gnn_rendered_simulators" / "pymdp"
    
    # Define base directory for execution logs from this step
    step_10_log_dir_base = pipeline_output_path / "pymdp_execute_logs"
    try:
        step_10_log_dir_base.mkdir(parents=True, exist_ok=True)
        logger.info(f"Execution logs for Step 10 will be stored in: {step_10_log_dir_base}")
    except OSError as e:
        logger.error(f"Could not create base log directory {step_10_log_dir_base}: {e}")
        # Proceeding without dedicated file logs if base dir creation fails, but log an error.
        # Alternatively, could return False here. For now, attempt to continue.

    logger.info(f"Searching for PyMDP scripts to execute in: {rendered_pymdp_base_dir}")
    if not rendered_pymdp_base_dir.is_dir():
        logger.warning(f"PyMDP rendered scripts directory not found: {rendered_pymdp_base_dir}")
        logger.warning("This might be expected if no PyMDP models were rendered in step 9.")
        return True # Not a failure of this step, just no scripts to run.

    glob_pattern = "**/*.py" if recursive_search else "*.py"
    pymdp_scripts = list(rendered_pymdp_base_dir.glob(glob_pattern))

    if not pymdp_scripts:
        logger.info(f"No PyMDP scripts (matching '{glob_pattern}') found in {rendered_pymdp_base_dir}.")
        return True # No scripts to run is not an error for this runner.

    logger.info(f"Found {len(pymdp_scripts)} PyMDP script(s) to execute.")

    all_executions_successful = True
    overall_summary = []

    # Determine the python executable to use (prefer venv if available)
    python_executable = sys.executable # Default to current Python
    project_root = Path(__file__).resolve().parent.parent # src/
    venv_python = project_root / ".venv" / "bin" / "python"
    if venv_python.exists():
        python_executable = str(venv_python)
        logger.info(f"Using Python executable from virtual environment: {python_executable}")
    else:
        logger.info(f"Using system Python executable: {python_executable}")

    for script_path in pymdp_scripts:
        script_stem = script_path.stem
        script_log_dir = step_10_log_dir_base / script_stem
        try:
            script_log_dir.mkdir(parents=True, exist_ok=True)
        except OSError as e:
            logger.error(f"Could not create log directory {script_log_dir} for {script_path.name}: {e}. Logs will not be saved to files for this script.")
            # Fallback: don't use script_log_dir for this script if creation fails
            current_script_log_dir = None 
        else:
            current_script_log_dir = script_log_dir

        logger.info(f"  Executing PyMDP script: {script_path.relative_to(pipeline_output_path)}")
        stdout_path = current_script_log_dir / "stdout.log" if current_script_log_dir else None
        stderr_path = current_script_log_dir / "stderr.log" if current_script_log_dir else None
        log_file_info = f" (Logs: {current_script_log_dir})" if current_script_log_dir else " (File logging disabled due to dir error)"

        try:
            # Scripts are run with their own directory as CWD to handle relative paths within the script if any.
            run_cwd = script_path.parent
            env = os.environ.copy()
            # Ensure PYTHONPATH includes project root and venv site-packages for consistency
            project_root_str = str(project_root)
            venv_site_packages_path = str(project_root / ".venv" / "lib" / f"python{sys.version_info.major}.{sys.version_info.minor}" / "site-packages")
            
            current_python_path = env.get("PYTHONPATH", "")
            path_parts = {project_root_str, venv_site_packages_path}
            if current_python_path:
                path_parts.update(current_python_path.split(os.pathsep))
            
            env["PYTHONPATH"] = os.pathsep.join(sorted(list(path_parts)))

            if verbose:
                logger.debug(f"      Using PYTHONPATH for subprocess: {env['PYTHONPATH']}")

            process = subprocess.run(
                [python_executable, str(script_path.name)],
                capture_output=True,
                text=True,
                check=False, # Don't raise exception on non-zero exit, we handle it
                cwd=run_cwd,
                env=env
            )

            # Save stdout and stderr to files
            stdout_log_path = script_log_dir / "stdout.log"
            stderr_log_path = script_log_dir / "stderr.log"
            try:
                with open(stdout_log_path, "w", encoding='utf-8') as f_out:
                    f_out.write(process.stdout if process.stdout else "")
                if verbose: logger.debug(f"      Stdout successfully written to {stdout_log_path}")
                with open(stderr_log_path, "w", encoding='utf-8') as f_err:
                    f_err.write(process.stderr if process.stderr else "")
                if verbose: logger.debug(f"      Stderr successfully written to {stderr_log_path}")
            except IOError as e:
                logger.error(f"    ❌ Error writing log files for {script_path.name} to {script_log_dir}: {e}")
                # Continue, but this script's logs might be missing

            script_summary_data = {
                "status": "Unknown", 
                "log_dir": str(script_log_dir),
                "stdout_preview": process.stdout[:300].strip() if process.stdout else "",
                "stderr_preview": process.stderr.strip() if process.stderr else ""
            }

            if process.returncode == 0:
                script_summary_data["status"] = "Success"
                logger.info(f"    ✅ Execution successful for: {script_path.name} (Logs: {script_log_dir})")
                if verbose:
                    if process.stdout:
                        logger.debug(f"      Stdout Preview (see {stdout_log_path.name} for full):\n{process.stdout[:300].strip()}...")
                    if process.stderr:
                        logger.warning(f"      Stderr Output from {script_path.name} (see {stderr_log_path.name} for full):\n{process.stderr.strip()}")
            else:
                script_summary_data["status"] = "Failure"
                logger.error(f"    ❌ Execution FAILED for: {script_path.name} (Return Code: {process.returncode}, Logs: {script_log_dir})")
                all_executions_successful = False
                # For failed scripts, log previews even if not verbose, as this is important diagnostic info from the runner's perspective.
                if process.stdout:
                    logger.error(f"      Stdout from failed {script_path.name} (see {stdout_log_path.name} for full):\n{process.stdout.strip()}")
                if process.stderr:
                    logger.error(f"      Stderr from failed {script_path.name} (see {stderr_log_path.name} for full):\n{process.stderr.strip()}")
            
            overall_summary.append((str(script_path.name), script_summary_data["status"], script_summary_data["stdout_preview"], script_summary_data["stderr_preview"], str(script_log_dir)))
        except Exception as e:
            all_executions_successful = False
            logger.error(f"    ❌ Exception during execution of {script_path.name}: {e}{log_file_info}", exc_info=verbose)
            if current_script_log_dir: # Attempt to save exception to a file too
                try:
                    with open(current_script_log_dir / "exception.log", 'w') as f_exc:
                        import traceback
                        f_exc.write(f"Exception: {e}\n")
                        f_exc.write(traceback.format_exc())
                except OSError as e_write:
                    logger.error(f"    Could not write exception log for {script_path.name}: {e_write}")
            overall_summary.append((str(script_path.name), "Exception", str(e), str(current_script_log_dir if current_script_log_dir else "N/A")))

    logger.info("--- PyMDP Execution Summary ---")
    total_scripts = len(overall_summary)
    successful_scripts = sum(1 for data in overall_summary if data[1] == "Success")
    failed_scripts = total_scripts - successful_scripts

    logger.info(f"  Total scripts processed: {total_scripts}")
    logger.info(f"  Successfully executed: {successful_scripts}")
    logger.info(f"  Failed: {failed_scripts}")

    if verbose and failed_scripts > 0 : # Only print detailed summary of failures if verbose
        logger.info("  Details of failed/warning executions:")
        for name, status, stdout_preview, stderr_preview, log_dir in overall_summary:
            if status != "Success":
                logger.warning(f"    - Script: {name}")
                logger.warning(f"      Status: {status}")
                logger.warning(f"      Log Dir: {log_dir}")
                if stderr_preview: # Only show stderr preview from summary if it exists
                     logger.warning(f"      Stderr Preview: {stderr_preview[:300]}...")

    return all_executions_successful

if __name__ == '__main__':
    # This block is for testing pymdp_runner.py directly.
    # It requires the GNN pipeline to have run up to step 9 (render)
    # and produced some PyMDP scripts in the expected output location.

    # Setup basic logging for standalone run
    logging.basicConfig(
        level=logging.DEBUG, # Show debug for standalone test
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )

    # Determine project root assuming this script is in src/execute/
    # and output is in <project_root>/output/
    project_root_dir = Path(__file__).resolve().parent.parent.parent
    test_output_dir = project_root_dir / "output"

    logger.info(f"Standalone Test: Running PyMDP scripts from output directory: {test_output_dir}")
    success = run_pymdp_scripts(
        pipeline_output_dir=str(test_output_dir),
        recursive_search=True, # Typically rendered scripts might be in subdirs
        verbose=True
    )

    if success:
        logger.info("Standalone Test: All PyMDP scripts executed successfully.")
        sys.exit(0)
    else:
        logger.error("Standalone Test: Some PyMDP scripts failed to execute.")
        sys.exit(1) 