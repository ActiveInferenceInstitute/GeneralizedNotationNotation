#!/usr/bin/env python3
"""
ActiveInference.jl script execution module for the GNN Processing Pipeline.

This module provides functions to execute ActiveInference.jl scripts that were
generated by the GNN rendering step (9_render.py).
"""

import logging
import os
import subprocess
import sys
from pathlib import Path
from typing import List, Optional, Union, Dict, Any, Tuple

logger = logging.getLogger(__name__)

def is_julia_available() -> bool:
    """
    Check if Julia is available in the system path.
    
    Returns:
        bool: True if Julia is available, False otherwise
    """
    try:
        result = subprocess.run(
            ["julia", "--version"], 
            capture_output=True, 
            text=True, 
            check=False
        )
        if result.returncode == 0:
            logger.info(f"Julia is available: {result.stdout.strip()}")
            return True
        else:
            logger.warning("Julia command returned non-zero exit code")
            return False
    except FileNotFoundError:
        logger.warning("Julia executable not found in PATH")
        return False
    except Exception as e:
        logger.warning(f"Error checking Julia availability: {e}")
        return False

def find_activeinference_scripts(
    base_dir: Union[str, Path], 
    recursive: bool = True
) -> List[Path]:
    """
    Find ActiveInference.jl scripts in the specified directory.
    
    Args:
        base_dir: Directory to search for ActiveInference.jl scripts
        recursive: Whether to search recursively in subdirectories
        
    Returns:
        List of paths to ActiveInference.jl script files
    """
    base_path = Path(base_dir)
    if not base_path.exists():
        logger.warning(f"Directory not found: {base_path}")
        return []
    
    # Look for Julia files with activeinference patterns
    jl_files = list(base_path.glob("**/*.jl" if recursive else "*.jl"))
    
    # Filter to only include ActiveInference scripts
    activeinference_files = [
        f for f in jl_files 
        if "activeinference" in f.name.lower() or 
           any(pattern in f.name.lower() for pattern in [
               "actinf", "active_inference", "pomdp", "belief", "agent"
           ])
    ]
    
    logger.info(f"Found {len(activeinference_files)} ActiveInference.jl scripts in {base_path}")
    
    return activeinference_files

def execute_activeinference_script(
    script_path: Path, 
    verbose: bool = False,
    output_dir: Optional[Path] = None
) -> bool:
    """
    Execute a single ActiveInference.jl script with enhanced error handling.
    
    Args:
        script_path: Path to the ActiveInference.jl script
        verbose: Whether to enable verbose output
        output_dir: Optional output directory for results
        
    Returns:
        bool: True if execution was successful, False otherwise
    """
    if not script_path.exists():
        logger.error(f"Script file not found: {script_path}")
        return False
    
    logger.info(f"Executing ActiveInference.jl script: {script_path}")
    
    # Check if Julia is available
    if not is_julia_available():
        logger.error("Julia is not available, cannot execute ActiveInference.jl scripts")
        return False
    
    # Check if the script has valid Julia syntax
    try:
        # Basic syntax check using Julia
        syntax_check_cmd = ["julia", "-e", f"include(\"{script_path}\")"]
        result = subprocess.run(
            syntax_check_cmd,
            capture_output=True,
            text=True,
            check=False,
            timeout=30
        )
        if result.returncode != 0:
            logger.warning(f"Syntax check failed for {script_path.name}: {result.stderr}")
            # Continue anyway, as some scripts might have runtime dependencies
    except Exception as e:
        logger.debug(f"Syntax check skipped for {script_path.name}: {e}")
    
    try:
        # Convert to absolute path to avoid path resolution issues
        abs_script_path = script_path.resolve()
        
        # Prepare Julia command with enhanced environment
        cmd = ["julia", "--project=@.", str(abs_script_path)]
        
        # Add output directory argument if provided
        if output_dir:
            output_dir.mkdir(parents=True, exist_ok=True)
            cmd.extend(["--output-dir", str(output_dir)])
        
        logger.debug(f"Running command: {' '.join(cmd)}")
        
        # Set environment variables for Julia
        env = os.environ.copy()
        env["JULIA_PROJECT"] = str(abs_script_path.parent)
        env["JULIA_DEPOT_PATH"] = str(abs_script_path.parent / ".julia")
        
        # Create Julia project environment and install dependencies
        project_file = abs_script_path.parent / "Project.toml"
        if not project_file.exists():
            logger.info(f"Creating Julia project environment in {abs_script_path.parent}")
            try:
                # Initialize project and install required packages
                install_cmd = '''
using Pkg; 
Pkg.activate("."); 
Pkg.add(["ActiveInference", "Distributions", "LinearAlgebra", "Random", "Plots", "StatsBase"]);
Pkg.instantiate()
'''
                subprocess.run(
                    ["julia", "--project=@.", "-e", install_cmd],
                    cwd=abs_script_path.parent,
                    capture_output=True,
                    text=True,
                    check=False,
                    timeout=300  # 5 minutes for package installation
                )
                logger.info("Julia packages installed successfully")
            except Exception as e:
                logger.warning(f"Could not initialize Julia project: {e}")
        
        # Execute the Julia script with timeout
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False,
            env=env,
            cwd=abs_script_path.parent,
            timeout=600  # 10 minute timeout for Julia scripts
        )
        
        # Process the execution result
        if result.returncode == 0:
            logger.info(f"✅ Script executed successfully: {script_path.name}")
            if verbose and result.stdout.strip():
                logger.debug(f"Output from {script_path.name}:\n{result.stdout}")
            return True
        else:
            logger.error(f"❌ Script execution failed with return code {result.returncode}: {script_path.name}")
            if result.stderr.strip():
                logger.error(f"Error output:\n{result.stderr}")
            if result.stdout.strip():
                logger.debug(f"Standard output:\n{result.stdout}")
            
            # Check for common Julia package issues
            stderr_lower = result.stderr.lower()
            if "package" in stderr_lower and "not found" in stderr_lower:
                logger.error("💡 This appears to be a missing Julia package issue.")
                logger.error("💡 Try running: julia --project=@. -e 'using Pkg; Pkg.add(\"PackageName\")'")
            
            return False
    except subprocess.TimeoutExpired:
        logger.error(f"❌ Script execution timed out: {script_path.name}")
        return False
    except Exception as e:
        logger.error(f"❌ Error executing script {script_path.name}: {e}")
        return False

def run_activeinference_analysis(
    pipeline_output_dir: Union[str, Path],
    execution_output_dir: Optional[Union[str, Path]] = None,
    recursive_search: bool = True,
    verbose: bool = False,
    analysis_type: str = "comprehensive"
) -> bool:
    """
    Find and run ActiveInference.jl analysis scripts on rendered models.
    
    Args:
        pipeline_output_dir: Main pipeline output directory
        execution_output_dir: Specific directory for ActiveInference.jl execution outputs (optional)
        recursive_search: Whether to search recursively for scripts
        verbose: Whether to enable verbose output
        analysis_type: Type of analysis to run ('basic', 'comprehensive', 'all')
        
    Returns:
        bool: True if analysis completed successfully, False if any failed
    """
    # Check if Julia is available
    if not is_julia_available():
        logger.error("Julia is not available, cannot execute ActiveInference.jl scripts")
        return False
    
    # Set up execution output directory
    if execution_output_dir:
        exec_output_dir = Path(execution_output_dir)
        exec_output_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f"ActiveInference.jl execution outputs will be saved to: {exec_output_dir}")
        results_dir = exec_output_dir
    else:
        results_dir = Path(pipeline_output_dir) / "execution_results" / "activeinference_jl"
    
    # Construct the path to the ActiveInference.jl outputs
    activeinference_dir = Path(pipeline_output_dir) / "gnn_rendered_simulators" / "activeinference_jl"
    
    logger.info(f"Looking for ActiveInference.jl scripts in: {activeinference_dir}")
    
    # Find all ActiveInference.jl scripts
    script_files = find_activeinference_scripts(activeinference_dir, recursive_search)
    
    if not script_files:
        logger.info("No ActiveInference.jl scripts found")
        # If no rendered scripts, run the analysis suite on any available GNN data
        logger.info("Running ActiveInference.jl analysis suite on available data")
        return run_analysis_suite(pipeline_output_dir, analysis_type, verbose)
    
    # Execute each script
    success_count = 0
    failure_count = 0
    
    for script_file in script_files:
        output_dir = results_dir / script_file.stem
        if execute_activeinference_script(script_file, verbose, output_dir):
            success_count += 1
        else:
            failure_count += 1
    
    # Report execution results
    total_count = success_count + failure_count
    logger.info(f"ActiveInference.jl script execution summary: {success_count} succeeded, {failure_count} failed, {total_count} total")
    
    # Consider the overall run successful if any scripts succeeded
    return failure_count == 0 or success_count > 0

def run_analysis_suite(
    pipeline_output_dir: Union[str, Path],
    analysis_type: str = "comprehensive",
    verbose: bool = False
) -> bool:
    """
    Run the ActiveInference.jl analysis suite on pipeline outputs.
    
    Args:
        pipeline_output_dir: Main pipeline output directory
        analysis_type: Type of analysis ('basic', 'comprehensive', 'all')
        verbose: Whether to enable verbose output
        
    Returns:
        bool: True if analysis completed successfully
    """
    try:
        # Get the path to our analysis scripts
        current_dir = Path(__file__).parent
        
        # Determine which analysis script to run
        if analysis_type == "basic":
            analysis_script = current_dir / "activeinference_runner.jl"
        elif analysis_type == "comprehensive":
            analysis_script = current_dir / "enhanced_analysis_suite.jl"
        elif analysis_type == "all":
            # Run multiple analysis scripts
            scripts = [
                "activeinference_runner.jl",
                "enhanced_analysis_suite.jl",
                "statistical_analysis.jl",
                "uncertainty_quantification.jl",
                "meta_cognitive_analysis.jl"
            ]
            
            success_count = 0
            for script_name in scripts:
                script_path = current_dir / script_name
                if script_path.exists():
                    results_dir = Path(pipeline_output_dir) / "execution_results" / "activeinference_jl" / script_path.stem
                    if execute_activeinference_script(script_path, verbose, results_dir):
                        success_count += 1
                    else:
                        logger.warning(f"Analysis script failed: {script_name}")
                else:
                    logger.warning(f"Analysis script not found: {script_name}")
            
            return success_count > 0
        else:
            logger.error(f"Unknown analysis type: {analysis_type}")
            return False
        
        # Run the selected analysis script
        if analysis_script.exists():
            results_dir = Path(pipeline_output_dir) / "execution_results" / "activeinference_jl" / analysis_script.stem
            return execute_activeinference_script(analysis_script, verbose, results_dir)
        else:
            logger.error(f"Analysis script not found: {analysis_script}")
            return False
    
    except Exception as e:
        logger.error(f"Error running ActiveInference.jl analysis suite: {e}")
        return False

if __name__ == "__main__":
    # Setup logging for standalone execution
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        stream=sys.stdout
    )
    
    # Parse command-line arguments for standalone execution
    import argparse
    parser = argparse.ArgumentParser(description="Execute ActiveInference.jl scripts generated by the GNN rendering step")
    parser.add_argument("--output-dir", type=Path, default="../output",
                       help="Main pipeline output directory")
    parser.add_argument("--recursive", action=argparse.BooleanOptionalAction, default=True,
                       help="Recursively search for scripts in the output directory")
    parser.add_argument("--verbose", action=argparse.BooleanOptionalAction, default=False,
                       help="Enable verbose output")
    parser.add_argument("--analysis-type", choices=["basic", "comprehensive", "all"], default="comprehensive",
                       help="Type of analysis to run")
    
    args = parser.parse_args()
    
    # Enable verbose logging if requested
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    # Run the analysis
    success = run_activeinference_analysis(
        pipeline_output_dir=args.output_dir,
        recursive_search=args.recursive,
        verbose=args.verbose,
        analysis_type=args.analysis_type
    )
    
    # Exit with appropriate status code
    sys.exit(0 if success else 1) 