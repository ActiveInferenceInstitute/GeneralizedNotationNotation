#!/usr/bin/env python3
"""
ActiveInference.jl script execution module for the GNN Processing Pipeline.

This module provides functions to execute ActiveInference.jl scripts that were
generated by the GNN rendering step (9_render.py) with comprehensive environmental setup.

Features:
- Robust Julia environment setup and validation
- Comprehensive package installation and dependency management
- Environment health checks and reporting
- Fallback mechanisms for failed setups
- Detailed logging and error reporting
"""

import logging
import os
import subprocess
import sys
import json
import time
from pathlib import Path
from typing import List, Optional, Union, Dict, Any, Tuple

logger = logging.getLogger(__name__)

def is_julia_available() -> bool:
    """
    Check if Julia is available in the system path.
    
    Returns:
        bool: True if Julia is available, False otherwise
    """
    try:
        result = subprocess.run(
            ["julia", "--version"], 
            capture_output=True, 
            text=True, 
            check=False,
            timeout=10
        )
        if result.returncode == 0:
            version_info = result.stdout.strip()
            logger.info(f"Julia is available: {version_info}")
            
            # Extract version number for compatibility check
            try:
                import re
                version_match = re.search(r'julia version (\d+\.\d+\.\d+)', version_info.lower())
                if version_match:
                    version_str = version_match.group(1)
                    version_parts = [int(x) for x in version_str.split('.')]
                    
                    # Check minimum version (1.6.0)
                    if version_parts[0] > 1 or (version_parts[0] == 1 and version_parts[1] >= 6):
                        logger.info(f"✅ Julia version {version_str} meets minimum requirements (1.6.0)")
                        return True
                    else:
                        logger.warning(f"⚠️ Julia version {version_str} is below minimum (1.6.0)")
                        return False
                        
            except Exception as e:
                logger.debug(f"Could not parse Julia version, assuming compatible: {e}")
                return True
                
        else:
            logger.warning("Julia command returned non-zero exit code")
            return False
    except FileNotFoundError:
        logger.warning("Julia executable not found in PATH")
        return False
    except subprocess.TimeoutExpired:
        logger.warning("Julia version check timed out")
        return False
    except Exception as e:
        logger.warning(f"Error checking Julia availability: {e}")
        return False

def setup_julia_environment(project_dir: Path, force_setup: bool = False, verbose: bool = False) -> bool:
    """
    Setup Julia environment using the comprehensive setup script.
    
    Args:
        project_dir: Path to the ActiveInference.jl project directory
        force_setup: Whether to force reinstall all packages
        verbose: Whether to enable verbose setup output
        
    Returns:
        bool: True if setup was successful, False otherwise
    """
    logger.info("Setting up Julia environment...")
    
    # Check if Julia is available
    if not is_julia_available():
        logger.error("Julia is not available, cannot setup environment")
        return False
    
    # Look for setup script
    setup_script = project_dir / "setup_environment.jl"
    if not setup_script.exists():
        logger.warning(f"Setup script not found at {setup_script}")
        logger.info("Falling back to basic package instantiation...")
        return _fallback_environment_setup(project_dir)
    
    # Prepare setup command
    setup_args = []
    if verbose:
        setup_args.append("--verbose")
    if force_setup:
        setup_args.append("--force-reinstall")
    
    cmd = ["julia", "--project=" + str(project_dir), str(setup_script)] + setup_args
    
    logger.info(f"Running comprehensive environment setup...")
    logger.debug(f"Setup command: {' '.join(cmd)}")
    
    try:
        # Run setup with extended timeout
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False,
            cwd=project_dir,
            timeout=1800  # 30 minutes for comprehensive setup
        )
        
        if result.returncode == 0:
            logger.info("✅ Julia environment setup completed successfully")
            if verbose and result.stdout.strip():
                logger.debug(f"Setup output:\n{result.stdout}")
            return True
        else:
            logger.error(f"❌ Environment setup failed with return code {result.returncode}")
            if result.stderr.strip():
                logger.error(f"Setup errors:\n{result.stderr}")
            if result.stdout.strip():
                logger.debug(f"Setup output:\n{result.stdout}")
            
            # Try fallback setup
            logger.info("Attempting fallback environment setup...")
            return _fallback_environment_setup(project_dir)
            
    except subprocess.TimeoutExpired:
        logger.error("❌ Environment setup timed out after 30 minutes")
        logger.info("Attempting fallback environment setup...")
        return _fallback_environment_setup(project_dir)
        
    except Exception as e:
        logger.error(f"❌ Error during environment setup: {e}")
        logger.info("Attempting fallback environment setup...")
        return _fallback_environment_setup(project_dir)

def _fallback_environment_setup(project_dir: Path) -> bool:
    """
    Fallback environment setup using basic Pkg.instantiate().
    
    Args:
        project_dir: Path to the ActiveInference.jl project directory
        
    Returns:
        bool: True if fallback setup was successful, False otherwise
    """
    logger.info("Running fallback environment setup...")
    
    try:
        # Basic package instantiation
        instantiate_cmd = ["julia", f"--project={project_dir}", "-e", "using Pkg; Pkg.instantiate()"]
        logger.debug(f"Running: {' '.join(instantiate_cmd)}")
        
        result = subprocess.run(
            instantiate_cmd,
            capture_output=True,
            text=True,
            check=False,
            cwd=project_dir,
            timeout=600  # 10 minutes for basic setup
        )
        
        if result.returncode == 0:
            logger.info("✅ Fallback environment setup completed")
            
            # Try to validate core packages
            core_packages = ["ActiveInference", "Distributions", "LinearAlgebra"]
            validation_success = True
            
            for package in core_packages:
                if not _validate_package(project_dir, package):
                    logger.warning(f"⚠️ Core package '{package}' validation failed")
                    validation_success = False
            
            if validation_success:
                logger.info("✅ Core packages validated successfully")
            else:
                logger.warning("⚠️ Some core packages failed validation")
            
            return True
        else:
            logger.error(f"❌ Fallback setup failed: {result.stderr}")
            return False
            
    except subprocess.TimeoutExpired:
        logger.error("❌ Fallback setup timed out")
        return False
    except Exception as e:
        logger.error(f"❌ Error in fallback setup: {e}")
        return False

def _validate_package(project_dir: Path, package_name: str) -> bool:
    """
    Validate that a package can be loaded.
    
    Args:
        project_dir: Path to the Julia project directory
        package_name: Name of the package to validate
        
    Returns:
        bool: True if package loads successfully, False otherwise
    """
    try:
        cmd = ["julia", f"--project={project_dir}", "-e", f"using {package_name}; println(\"✅ {package_name} loaded\")"]
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False,
            cwd=project_dir,
            timeout=30
        )
        return result.returncode == 0
    except Exception:
        return False

def get_environment_status(project_dir: Path) -> Dict[str, Any]:
    """
    Get detailed status of the Julia environment.
    
    Args:
        project_dir: Path to the Julia project directory
        
    Returns:
        Dict containing environment status information
    """
    status = {
        "julia_available": is_julia_available(),
        "project_toml_exists": (project_dir / "Project.toml").exists(),
        "manifest_toml_exists": (project_dir / "Manifest.toml").exists(),
        "setup_script_exists": (project_dir / "setup_environment.jl").exists(),
        "environment_report_exists": (project_dir / "environment_report.json").exists(),
        "core_packages_status": {},
        "setup_recommendation": "unknown"
    }
    
    # Check core packages
    core_packages = ["ActiveInference", "Distributions", "LinearAlgebra", "Random", "Statistics"]
    for package in core_packages:
        status["core_packages_status"][package] = _validate_package(project_dir, package)
    
    # Determine setup recommendation
    core_packages_working = all(status["core_packages_status"].values())
    
    if not status["julia_available"]:
        status["setup_recommendation"] = "install_julia"
    elif not status["project_toml_exists"]:
        status["setup_recommendation"] = "create_project"
    elif not core_packages_working:
        status["setup_recommendation"] = "run_setup"
    else:
        status["setup_recommendation"] = "ready"
    
    return status

def execute_activeinference_script(
    script_path: Path, 
    verbose: bool = False,
    output_dir: Optional[Path] = None,
    setup_environment: bool = True
) -> bool:
    """
    Execute a single ActiveInference.jl script with enhanced environmental setup.
    
    Args:
        script_path: Path to the ActiveInference.jl script
        verbose: Whether to enable verbose output
        output_dir: Optional output directory for results
        setup_environment: Whether to setup/validate environment before execution
        
    Returns:
        bool: True if execution was successful, False otherwise
    """
    if not script_path.exists():
        logger.error(f"Script file not found: {script_path}")
        return False
    
    logger.info(f"Executing ActiveInference.jl script: {script_path}")
    
    # Determine the project directory
    project_dir = script_path.parent
    while project_dir.name != "activeinference_jl" and project_dir.parent != project_dir:
        project_dir = project_dir.parent
    
    if project_dir.name != "activeinference_jl":
        project_dir = script_path.parent
    
    logger.debug(f"Using Julia project directory: {project_dir}")
    
    # Environment setup and validation
    if setup_environment:
        env_status = get_environment_status(project_dir)
        logger.debug(f"Environment status: {env_status['setup_recommendation']}")
        
        if env_status["setup_recommendation"] == "install_julia":
            logger.error("Julia is not available, cannot execute script")
            return False
        elif env_status["setup_recommendation"] in ["create_project", "run_setup"]:
            logger.info("Environment needs setup, running comprehensive setup...")
            if not setup_julia_environment(project_dir, verbose=verbose):
                logger.error("Environment setup failed, cannot execute script reliably")
                # Continue anyway for fallback execution
        else:
            logger.debug("Environment appears ready")
    
    try:
        # Convert to absolute path
        abs_script_path = script_path.resolve()
        
        # Prepare Julia command
        cmd = ["julia", f"--project={project_dir}", str(abs_script_path)]
        
        # Add output directory argument if provided
        if output_dir:
            output_dir.mkdir(parents=True, exist_ok=True)
            cmd.extend(["--output-dir", str(output_dir)])
        
        logger.debug(f"Running command: {' '.join(cmd)}")
        
        # Set environment variables
        env = os.environ.copy()
        env["JULIA_PROJECT"] = str(project_dir)
        
        # Execute the script
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True,
            check=False,
            env=env,
            cwd=project_dir,
            timeout=600  # 10 minute timeout for script execution
        )
        
        # Process the execution result
        if result.returncode == 0:
            logger.info(f"✅ Script executed successfully: {script_path.name}")
            if verbose and result.stdout.strip():
                logger.debug(f"Output from {script_path.name}:\n{result.stdout}")
            return True
        else:
            logger.error(f"❌ Script execution failed with return code {result.returncode}: {script_path.name}")
            if result.stderr.strip():
                logger.error(f"Error output:\n{result.stderr}")
            if result.stdout.strip():
                logger.debug(f"Standard output:\n{result.stdout}")
            
            # Provide helpful error analysis
            stderr_lower = result.stderr.lower()
            if "package" in stderr_lower and ("not found" in stderr_lower or "not in registry" in stderr_lower):
                logger.error("💡 This appears to be a missing Julia package issue.")
                logger.error("💡 Try running the environment setup with --force-reinstall")
            elif "method error" in stderr_lower or "undefvarerror" in stderr_lower:
                logger.error("💡 This appears to be a package version compatibility issue.")
                logger.error("💡 The script may need updates for the current ActiveInference.jl version")
            
            return False
            
    except subprocess.TimeoutExpired:
        logger.error(f"❌ Script execution timed out: {script_path.name}")
        return False
    except Exception as e:
        logger.error(f"❌ Error executing script {script_path.name}: {e}")
        return False

def find_activeinference_scripts(
    search_dir: Path, 
    recursive: bool = True,
    include_patterns: List[str] = None
) -> List[Path]:
    """
    Find ActiveInference.jl scripts in a directory.
    
    Args:
        search_dir: Directory to search for scripts
        recursive: Whether to search recursively
        include_patterns: Patterns to match (default: ["*.jl"])
        
    Returns:
        List of script paths found
    """
    if include_patterns is None:
        include_patterns = ["*.jl"]
    
    script_files = []
    
    if not search_dir.exists():
        logger.warning(f"Search directory does not exist: {search_dir}")
        return script_files
    
    try:
        if recursive:
            for pattern in include_patterns:
                script_files.extend(search_dir.rglob(pattern))
        else:
            for pattern in include_patterns:
                script_files.extend(search_dir.glob(pattern))
        
        # Filter out setup and utility scripts
        filtered_scripts = []
        for script in script_files:
            if script.name.startswith("setup_") or script.name.startswith("_"):
                logger.debug(f"Skipping utility script: {script.name}")
                continue
            filtered_scripts.append(script)
        
        logger.info(f"Found {len(filtered_scripts)} ActiveInference.jl scripts in {search_dir}")
        return filtered_scripts
        
    except Exception as e:
        logger.error(f"Error finding scripts in {search_dir}: {e}")
        return []

def run_activeinference_analysis(
    pipeline_output_dir: Union[str, Path],
    execution_output_dir: Optional[Union[str, Path]] = None,
    recursive_search: bool = True,
    verbose: bool = False,
    analysis_type: str = "comprehensive",
    force_setup: bool = False
) -> bool:
    """
    Find and run ActiveInference.jl analysis scripts on rendered models with robust environment setup.
    
    Args:
        pipeline_output_dir: Main pipeline output directory
        execution_output_dir: Specific directory for ActiveInference.jl execution outputs (optional)
        recursive_search: Whether to search recursively for scripts
        verbose: Whether to enable verbose output
        analysis_type: Type of analysis to run ('basic', 'comprehensive', 'all')
        force_setup: Whether to force environment reinstallation
        
    Returns:
        bool: True if analysis completed successfully, False if any failed
    """
    logger.info("Starting ActiveInference.jl analysis with comprehensive environment setup...")
    
    # Check if Julia is available
    if not is_julia_available():
        logger.error("Julia is not available, cannot execute ActiveInference.jl scripts")
        return False
    
    # Set up execution output directory
    if execution_output_dir:
        exec_output_dir = Path(execution_output_dir)
    else:
        exec_output_dir = Path(pipeline_output_dir) / "execution_results" / "activeinference_jl"
    
    exec_output_dir.mkdir(parents=True, exist_ok=True)
    logger.info(f"ActiveInference.jl execution outputs will be saved to: {exec_output_dir}")
    
    # Find ActiveInference.jl rendered scripts
    activeinference_dir = Path(pipeline_output_dir) / "gnn_rendered_simulators" / "activeinference_jl"
    
    logger.info(f"Looking for ActiveInference.jl scripts in: {activeinference_dir}")
    
    if not activeinference_dir.exists():
        logger.error(f"ActiveInference.jl directory not found: {activeinference_dir}")
        return False
    
    # Setup environment first
    logger.info("Setting up Julia environment before script execution...")
    if not setup_julia_environment(activeinference_dir, force_setup=force_setup, verbose=verbose):
        logger.warning("Environment setup had issues, but continuing with script execution...")
    
    # Find scripts
    script_files = find_activeinference_scripts(activeinference_dir, recursive_search)
    
    if not script_files:
        logger.warning("No ActiveInference.jl scripts found")
        return True  # Not necessarily an error
    
    # Execute scripts
    successful_scripts = []
    failed_scripts = []
    
    logger.info(f"Executing {len(script_files)} ActiveInference.jl scripts...")
    
    for i, script_path in enumerate(script_files, 1):
        logger.info(f"[{i}/{len(script_files)}] Executing: {script_path.name}")
        
        # Create script-specific output directory
        script_output_dir = exec_output_dir / script_path.stem
        
        # Execute script (environment already setup)
        if execute_activeinference_script(
            script_path, 
            verbose=verbose, 
            output_dir=script_output_dir,
            setup_environment=False  # Already done above
        ):
            successful_scripts.append(script_path)
        else:
            failed_scripts.append(script_path)
    
    # Generate execution summary
    success_rate = len(successful_scripts) / len(script_files) if script_files else 0
    logger.info(f"ActiveInference.jl execution summary:")
    logger.info(f"  Total scripts: {len(script_files)}")
    logger.info(f"  Successful: {len(successful_scripts)}")
    logger.info(f"  Failed: {len(failed_scripts)}")
    logger.info(f"  Success rate: {success_rate:.1%}")
    
    if failed_scripts:
        logger.warning("Failed scripts:")
        for script in failed_scripts:
            logger.warning(f"  - {script.name}")
    
    # Save execution report
    execution_report = {
        "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
        "analysis_type": analysis_type,
        "environment_setup": {
            "force_setup": force_setup,
            "setup_successful": True  # We got this far
        },
        "execution_summary": {
            "total_scripts": len(script_files),
            "successful_scripts": len(successful_scripts),
            "failed_scripts": len(failed_scripts),
            "success_rate": success_rate
        },
        "successful_scripts": [str(p) for p in successful_scripts],
        "failed_scripts": [str(p) for p in failed_scripts],
        "output_directory": str(exec_output_dir)
    }
    
    report_file = exec_output_dir / "activeinference_execution_report.json"
    try:
        with open(report_file, 'w') as f:
            json.dump(execution_report, f, indent=2)
        logger.info(f"Execution report saved to: {report_file}")
    except Exception as e:
        logger.warning(f"Could not save execution report: {e}")
    
    return len(failed_scripts) == 0

# Alias for backward compatibility
run_analysis_suite = run_activeinference_analysis

if __name__ == "__main__":
    # Setup logging for standalone execution
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        stream=sys.stdout
    )
    
    # Parse command-line arguments for standalone execution
    import argparse
    parser = argparse.ArgumentParser(description="Execute ActiveInference.jl scripts generated by the GNN rendering step")
    parser.add_argument("--output-dir", type=Path, default="../output",
                       help="Main pipeline output directory")
    parser.add_argument("--recursive", action=argparse.BooleanOptionalAction, default=True,
                       help="Recursively search for scripts in the output directory")
    parser.add_argument("--verbose", action=argparse.BooleanOptionalAction, default=False,
                       help="Enable verbose output")
    parser.add_argument("--analysis-type", choices=["basic", "comprehensive", "all"], default="comprehensive",
                       help="Type of analysis to run")
    parser.add_argument("--force-setup", action=argparse.BooleanOptionalAction, default=False,
                       help="Force environment reinstallation before execution")
    
    args = parser.parse_args()
    
    # Enable verbose logging if requested
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    # Run the analysis
    success = run_activeinference_analysis(
        pipeline_output_dir=args.output_dir,
        recursive_search=args.recursive,
        verbose=args.verbose,
        analysis_type=args.analysis_type,
        force_setup=args.force_setup
    )
    
    # Exit with appropriate status code
    sys.exit(0 if success else 1) 