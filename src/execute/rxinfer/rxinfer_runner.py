#!/usr/bin/env python3
"""
RxInfer.jl script execution module for the GNN Processing Pipeline.

This module provides functions to execute RxInfer.jl scripts that were
generated by the GNN rendering step (11_render.py).
"""

import logging
import os
import subprocess
import sys
from pathlib import Path
from typing import List, Optional, Union, Dict, Any, Tuple

logger = logging.getLogger(__name__)

def is_julia_available() -> bool:
    """
    Check if Julia is available in the system path.
    
    Returns:
        bool: True if Julia is available, False otherwise
    """
    try:
        result = subprocess.run(
            ["julia", "--version"], 
            capture_output=True, 
            text=True, 
            check=False
        )
        if result.returncode == 0:
            logger.info(f"Julia is available: {result.stdout.strip()}")
            return True
        else:
            logger.warning("Julia command returned non-zero exit code")
            return False
    except FileNotFoundError:
        logger.warning("Julia executable not found in PATH")
        return False
    except Exception as e:
        logger.warning(f"Error checking Julia availability: {e}")
        return False

def find_rxinfer_scripts(
    base_dir: Union[str, Path], 
    recursive: bool = True
) -> List[Path]:
    """
    Find RxInfer.jl scripts in the specified directory.
    
    Args:
        base_dir: Directory to search for RxInfer.jl scripts
        recursive: Whether to search recursively in subdirectories
        
    Returns:
        List of paths to RxInfer.jl script files
    """
    base_path = Path(base_dir)
    if not base_path.exists():
        logger.warning(f"Directory not found: {base_path}")
        return []
    
    # Look for both .jl files and .toml configuration files
    jl_files = list(base_path.glob("**/*.jl" if recursive else "*.jl"))
    toml_files = list(base_path.glob("**/*_config.toml" if recursive else "*_config.toml"))
    
    # Filter to only include RxInfer scripts (typically with _rxinfer.jl suffix)
    rxinfer_jl_files = [f for f in jl_files if "_rxinfer.jl" in f.name]
    
    logger.info(f"Found {len(rxinfer_jl_files)} RxInfer.jl scripts and {len(toml_files)} TOML configuration files in {base_path}")
    
    # Return both script files and configuration files
    return rxinfer_jl_files + toml_files

def execute_rxinfer_script(
    script_path: Path, 
    verbose: bool = False
) -> bool:
    """
    Execute a single RxInfer.jl script.
    
    Args:
        script_path: Path to the RxInfer.jl script or TOML configuration
        verbose: Whether to enable verbose output
        
    Returns:
        bool: True if execution was successful, False otherwise
    """
    if not script_path.exists():
        logger.error(f"Script file not found: {script_path}")
        return False
    
    logger.info(f"Executing RxInfer script: {script_path}")
    
    try:
        # Different handling based on file type
        if script_path.suffix.lower() == '.jl':
            # For Julia files, run directly with julia
            cmd = ["julia", str(script_path)]
            logger.debug(f"Running command: {' '.join(cmd)}")
            
            # Execute the Julia script
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=False
            )
        elif script_path.suffix.lower() == '.toml':
            # For TOML configuration files, we need a Julia script that can load and run them
            # This would typically be a standard RxInfer.jl script that takes a config file as input
            
            # Look for a rxinfer_runner.jl script in the same directory as this Python file
            runner_script = Path(__file__).parent / "rxinfer_runner.jl"
            if not runner_script.exists():
                logger.error(f"RxInfer.jl runner script not found: {runner_script}")
                logger.error("Cannot execute TOML configuration without a runner script")
                return False
            
            cmd = ["julia", str(runner_script), str(script_path)]
            logger.debug(f"Running command: {' '.join(cmd)}")
            
            # Execute the Julia runner script with the TOML config file
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                check=False
            )
        else:
            logger.error(f"Unsupported file type: {script_path.suffix}")
            return False
        
        # Process the execution result
        if result.returncode == 0:
            logger.info(f"Script executed successfully: {script_path.name}")
            if verbose:
                logger.debug(f"Output from {script_path.name}:\n{result.stdout}")
            return True
        else:
            logger.error(f"Script execution failed with return code {result.returncode}: {script_path.name}")
            logger.error(f"Error output:\n{result.stderr}")
            return False
    except Exception as e:
        logger.error(f"Error executing script {script_path.name}: {e}")
        return False

def run_rxinfer_scripts(
    rendered_simulators_dir: Union[str, Path],
    execution_output_dir: Optional[Union[str, Path]] = None,
    recursive_search: bool = True,
    verbose: bool = False
) -> bool:
    """
    Find and run all RxInfer.jl scripts in the designated directory.
    
    Args:
        rendered_simulators_dir: Directory containing rendered simulators (target_dir from executor)
        execution_output_dir: Specific directory for RxInfer execution outputs (optional)
        recursive_search: Whether to search recursively for scripts
        verbose: Whether to enable verbose output
        
    Returns:
        bool: True if all scripts executed successfully, False if any failed
    """
    # Check if Julia is available
    if not is_julia_available():
        logger.error("Julia is not available, cannot execute RxInfer.jl scripts")
        return False
    
    # Set up execution output directory
    if execution_output_dir:
        exec_output_dir = Path(execution_output_dir)
        exec_output_dir.mkdir(parents=True, exist_ok=True)
        logger.info(f"RxInfer execution outputs will be saved to: {exec_output_dir}")
    
    # Construct the path to the RxInfer.jl scripts
    rxinfer_dir = Path(rendered_simulators_dir) / "rxinfer"
    
    logger.info(f"Looking for RxInfer.jl scripts in: {rxinfer_dir}")
    
    # Find all RxInfer.jl scripts
    script_files = find_rxinfer_scripts(rxinfer_dir, recursive_search)
    
    if not script_files:
        logger.info("No RxInfer.jl scripts found")
        return True  # Not an error, just nothing to do
    
    # Execute each script
    success_count = 0
    failure_count = 0
    
    for script_file in script_files:
        if execute_rxinfer_script(script_file, verbose):
            success_count += 1
        else:
            failure_count += 1
    
    # Report execution results
    total_count = success_count + failure_count
    logger.info(f"RxInfer.jl script execution summary: {success_count} succeeded, {failure_count} failed, {total_count} total")
    
    # Consider the overall run successful only if all scripts succeeded
    return failure_count == 0

if __name__ == "__main__":
    # Setup logging for standalone execution
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        stream=sys.stdout
    )
    
    # Parse command-line arguments for standalone execution
    import argparse
    parser = argparse.ArgumentParser(description="Execute RxInfer.jl scripts generated by the GNN rendering step")
    parser.add_argument("--output-dir", type=Path, default="../output",
                       help="Main pipeline output directory")
    parser.add_argument("--recursive", action=argparse.BooleanOptionalAction, default=True,
                       help="Recursively search for scripts in the output directory")
    parser.add_argument("--verbose", action=argparse.BooleanOptionalAction, default=False,
                       help="Enable verbose output")
    
    args = parser.parse_args()
    
    # Enable verbose logging if requested
    if args.verbose:
        logger.setLevel(logging.DEBUG)
    
    # Run the scripts
    success = run_rxinfer_scripts(
        rendered_simulators_dir=args.output_dir,
        recursive_search=args.recursive,
        verbose=args.verbose
    )
    
    # Exit with appropriate status code
    sys.exit(0 if success else 1) 