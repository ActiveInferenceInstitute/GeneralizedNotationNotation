#!/usr/bin/env python3
"""
PyMDP Agent Script - Standard_POMDP_Agent_v10

Generated by GNN PyMDP Renderer
"""

# =============================================================================
# WARNING: This is an automatically generated script from GNN
# If no matrix parameters were provided in the GNN spec, this script will
# contain minimal placeholder matrices that may not execute correctly.
# It is intended for basic structure only and may need manual adjustment.
# =============================================================================

import numpy as np
from pymdp.agent import Agent
from pymdp import utils
from pymdp import maths
import copy
import sys
import inspect
import traceback



# --- GNN to PyMDP Conversion Summary ---
# INFO: Starting GNN data extraction.
# DEBUG: Successfully parsed stringified direct_num_obs: [4, 2]
# DEBUG: Successfully parsed stringified direct_num_states: [3, 2]
# INFO: StateSpaceBlock not found or empty in GNN spec.
# INFO: Using direct 'num_obs_modalities' from GNN spec: [4, 2]
# INFO: Observation dimensions (num_obs) derived directly from gnn_spec.num_obs_modalities: [4, 2]
# INFO: Observation names generated as defaults (gnn_spec.obs_modality_names not found or mismatched).
# INFO: Using direct 'num_hidden_states_factors' from GNN spec: [3, 2]
# INFO: State dimensions (num_states) derived directly from gnn_spec.num_hidden_states_factors: [3, 2]
# INFO: State names generated as defaults (gnn_spec.hidden_state_factor_names not found or mismatched).
# INFO: No control factors found in StateSpaceBlock.HiddenStateFactors.
# INFO: Finished GNN data extraction.
# INFO: Matrix definitions not generated yet. Generating matrices...
# INFO: E_vector: No E (policy prior) specification found. Defaulting to None.
# INFO: Agent instantiation code not generated yet. Generating...
# INFO: Example usage code not generated yet. Generating...
# --- End of GNN to PyMDP Conversion Summary ---


num_obs = [4, 2]
num_modalities = 2
obs_names = ["modality_0", "modality_1"]
num_states = [3, 2]
num_factors = 2
state_names = ["factor_0", "factor_1"]
control_fac_idx = []
num_controls = [1, 1]

A_modality_0 = utils.norm_dist(np.ones((4, 3, 2)))
A_modality_1 = utils.norm_dist(np.ones((2, 3, 2)))
A = np.empty(2, dtype=object)
A[0] = A_modality_0
A[1] = A_modality_1
B_factor_0 = utils.norm_dist(np.eye(3)[:, :, np.newaxis])
B_factor_1 = utils.norm_dist(np.eye(2)[:, :, np.newaxis])
B = np.empty(2, dtype=object)
B[0] = B_factor_0
B[1] = B_factor_1
C_modality_0 = np.zeros(4)
C_modality_1 = np.zeros(2)
C = np.empty(2, dtype=object)
C[0] = C_modality_0
C[1] = C_modality_1
D_factor_0 = np.ones(3) / 3.0
D_factor_1 = np.ones(2) / 2.0
D = np.empty(2, dtype=object)
D[0] = D_factor_0
D[1] = D_factor_1
E = None

agent = Agent(
    A=A,
    B=B,
    C=C,
    D=D,
    E=E
)

# Set action names as agent attribute
agent.action_names = {}


# Example usage of the agent
if __name__ == "__main__":
    
    # --- Example Usage ---
    if __name__ == '__main__':
        # Initialize agent (already done above)
        # agent = Standard_POMDP_Agent_v10  # Agent is already instantiated above as 'agent'
        print(f"Agent 'Standard_POMDP_Agent_v10' initialized with {agent.num_factors if hasattr(agent, 'num_factors') else 'N/A'} factors and {agent.num_modalities if hasattr(agent, 'num_modalities') else 'N/A'} modalities.")
        o_current = [0, 0] # Example initial observation (e.g. first outcome for each modality)
        s_current = [0, 0] # Example initial true states for simulation
        T = 5 # Number of timesteps
        A_gen_process = copy.deepcopy(A)
        B_gen_process = copy.deepcopy(B)
    
        for t_step in range(T):
            print(f"\n--- Timestep {t_step + 1} ---")
            if o_current is not None:
                for g_idx, o_val in enumerate(o_current):
                    print(f"Observation ({obs_names[g_idx] if obs_names else f'Modality {g_idx}'}): {o_val}")
            # Infer states
            qs_current = agent.infer_states(o_current)
            if qs_current is not None:
                for f_idx, q_val in enumerate(qs_current):
                    print(f"Beliefs about {state_names[f_idx] if state_names else f'Factor {f_idx}'}: {q_val}")
    
            # Infer policies and sample action
            q_pi_current, efe_current = agent.infer_policies()
            if hasattr(agent, 'q_pi') and agent.q_pi is not None:
                print(f"Posterior over policies (q_pi): {agent.q_pi}")
            if efe_current is not None:
                print(f"Expected Free Energy (EFE): {efe_current}")
            action_agent = agent.sample_action()
            # Map agent's action (on control factors) to full environment action vector
            action_env = np.zeros(num_factors, dtype=int)
            if control_fac_idx and action_agent is not None:
                for i, cf_idx in enumerate(control_fac_idx):
                    action_env[cf_idx] = int(action_agent[i])
            # Construct action names for printing
            action_names_str_list = []
            if control_fac_idx and action_agent is not None:
                for i, cf_idx in enumerate(control_fac_idx):
                    factor_action_name_list = agent.action_names.get(cf_idx, []) if hasattr(agent, 'action_names') and isinstance(agent.action_names, dict) else []
                    action_idx_on_factor = int(action_agent[i])
                    if factor_action_name_list and action_idx_on_factor < len(factor_action_name_list):
                        action_names_str_list.append(f"{state_names[cf_idx] if state_names else f'Factor {cf_idx}'}: {factor_action_name_list[action_idx_on_factor]} (idx {action_idx_on_factor})")
                    else:
                        action_names_str_list.append(f"{state_names[cf_idx] if state_names else f'Factor {cf_idx}'}: Action idx {action_idx_on_factor}")
            print(f"Action taken: {', '.join(action_names_str_list) if action_names_str_list else 'No controllable actions or names not found'}")
    
            # Update true states of the environment based on action
            s_next = np.zeros(num_factors, dtype=int)
            if s_current is not None and B_gen_process is not None:
                for f_idx in range(num_factors):
                    # B_gen_process[f_idx] shape: (num_states[f_idx], num_states[f_idx], num_actions_for_this_factor_or_1)
                    action_for_factor = action_env[f_idx] if f_idx in control_fac_idx else 0
                    s_next[f_idx] = utils.sample(B_gen_process[f_idx][:, s_current[f_idx], action_for_factor])
            s_current = s_next.tolist()
            if s_current is not None:
                for f_idx, s_val in enumerate(s_current):
                    print(f"New true state ({state_names[f_idx] if state_names else f'Factor {f_idx}'}): {s_val}")
    
            # Generate next observation based on new true states
            o_next = np.zeros(num_modalities, dtype=int)
            if s_current is not None and A_gen_process is not None:
                for g_idx in range(num_modalities):
                    # A_gen_process[g_idx] shape: (num_obs[g_idx], num_states[0], num_states[1], ...)
                    # Construct index for A matrix: (outcome_idx, s_f0, s_f1, ...)
                    prob_vector = A_gen_process[g_idx][:, s_current[0], s_current[1]]
                    o_next[g_idx] = utils.sample(prob_vector)
            o_current = o_next.tolist()
    
        print(f"\nSimulation finished after {T} timesteps.")


print('--- PyMDP Runtime Debug ---')
try:
    import pymdp
    import inspect 
    import traceback 
    import ast

    # try:
    #     print(f'AGENT_SCRIPT: Imported pymdp version: {pymdp.__version__}') # Commented out
    # except AttributeError:
    #     print('AGENT_SCRIPT: pymdp.__version__ attribute not found.') # Commented out
    # print(f'AGENT_SCRIPT: pymdp module location: {pymdp.__file__}') # Commented out
    from pymdp.agent import Agent
    print(f'AGENT_SCRIPT: Imported Agent: {Agent}')
    print(f'AGENT_SCRIPT: Agent module location: {inspect.getfile(Agent)}')
    print('AGENT_SCRIPT: Checking for required variables in global scope:')
    print(f"  AGENT_SCRIPT: A = {A if 'A' in globals() else 'Not Defined'}")
    print(f"  AGENT_SCRIPT: B = {B if 'B' in globals() else 'Not Defined'}")
    print(f"  AGENT_SCRIPT: C = {C if 'C' in globals() else 'Not Defined'}")
    print(f"  AGENT_SCRIPT: D = {D if 'D' in globals() else 'Not Defined'}")
    print(f"  AGENT_SCRIPT: E = {E if 'E' in globals() else 'Not Defined'}")
    print(f"  AGENT_SCRIPT: control_fac_idx = {control_fac_idx if 'control_fac_idx' in globals() else 'Not Defined'}")
    print('  AGENT_SCRIPT: action_names = {}')
    print('  AGENT_SCRIPT: qs_initial = None')
    print('  AGENT_SCRIPT: agent_hyperparams = {}')
    print('AGENT_SCRIPT: Attempting to instantiate agent with defined parameters for debug...')
    
    local_agent_hyperparams_str_val = '{}'

    agent_params_for_debug = {}
    if local_agent_hyperparams_str_val and local_agent_hyperparams_str_val.strip() and local_agent_hyperparams_str_val.strip() != '{}':
        try:
            agent_params_for_debug = ast.literal_eval(local_agent_hyperparams_str_val)
            if not isinstance(agent_params_for_debug, dict):
                print("AGENT_SCRIPT: Debug - Parsed agent_hyperparams_dict_str ('" + local_agent_hyperparams_str_val + "') was not a dict.")
                agent_params_for_debug = {} 
        except Exception as e_hyper_parse:
            print("AGENT_SCRIPT: Debug - Error parsing agent_hyperparams_dict_str ('" + local_agent_hyperparams_str_val + "'): " + str(e_hyper_parse))
            agent_params_for_debug = {}
    else:
        print("AGENT_SCRIPT: Debug - agent_hyperparams_dict_str ('" + local_agent_hyperparams_str_val + "') is empty or '{}'. Using empty dict for debug agent.")
    
    debug_params_copy = {k: v for k, v in agent_params_for_debug.items() if not (isinstance(v, str) and v == 'None')}
    temp_agent = Agent(**debug_params_copy)
    print(f'AGENT_SCRIPT: Debug agent successfully instantiated: {temp_agent}')
except Exception as e_debug:
    print(f'AGENT_SCRIPT: Error during PyMDP runtime debug: {e_debug}')
    print("AGENT_SCRIPT: Traceback:")
    print(traceback.format_exc())
print('--- End PyMDP Runtime Debug ---')
