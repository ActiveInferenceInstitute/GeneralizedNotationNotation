#!/usr/bin/env python3
"""
PyMDP Agent Script - pymdp_agent_model

Generated by GNN PyMDP Renderer
"""

# =============================================================================
# WARNING: This is an automatically generated script from GNN
# If no matrix parameters were provided in the GNN spec, this script will
# contain minimal placeholder matrices that may not execute correctly.
# It is intended for basic structure only and may need manual adjustment.
# =============================================================================

import numpy as np
from pymdp.agent import Agent
from pymdp import utils
from pymdp import maths
import copy
import sys
import inspect
import traceback



# --- GNN to PyMDP Conversion Summary ---
# INFO: ModelName not found in GNN spec, using default 'pymdp_agent_model'.
# INFO: Starting GNN data extraction.
# INFO: Found parsed GNN data with 5 variables.
# INFO: Processing 5 variables from GNN data
# INFO: Processing variable: A with dimensions [3, 3] and type likelihood_matrix
# INFO: Recognized A matrix: 3 observations, 3 states
# INFO: Processing variable: B with dimensions [3, 3, 3] and type transition_matrix
# INFO: Recognized B matrix: 3 states, 3 actions
# INFO: Processing variable: C with dimensions [3] and type preference_vector
# INFO: Recognized C vector: 3 observations
# INFO: Processing variable: D with dimensions [3] and type prior_vector
# INFO: Recognized D vector: 3 states
# INFO: Processing variable: E with dimensions [3] and type policy
# INFO: Recognized E vector: 3 actions
# INFO: Extracted 1 observation modalities: ['state_observation']
# INFO: Extracted 1 state factors: ['location']
# INFO: Control factors: [0]
# INFO: ModelParameters not found or empty in GNN spec.
# INFO: Finished GNN data extraction.
# INFO: Matrix definitions not generated yet. Generating matrices...
# INFO: DEBUG: convert_A_matrix: type(self.A_spec) = <class 'NoneType'>, value = None
# INFO: DEBUG: _extract_initial_parameterization_matrices: initial_params = {'node_type': 'Parameter', 'source_location': None, 'metadata': {}, 'id': 'e205bf79-a36f-412c-af09-b66265a3fde1', 'name': 'E', 'value': [], 'type_hint': None, 'description': None}
# INFO: A matrix for A_state_observation set to default uniform.
# INFO: DEBUG: convert_B_matrix: type(self.B_spec) = <class 'NoneType'>, value = None
# INFO: DEBUG: _extract_initial_parameterization_matrices: initial_params = {'node_type': 'Parameter', 'source_location': None, 'metadata': {}, 'id': 'e205bf79-a36f-412c-af09-b66265a3fde1', 'name': 'E', 'value': [], 'type_hint': None, 'description': None}
# INFO: B matrix for B_location set to default uniform.
# INFO: DEBUG: convert_C_vector: self.C_spec = None
# INFO: DEBUG: _extract_initial_parameterization_matrices: initial_params = {'node_type': 'Parameter', 'source_location': None, 'metadata': {}, 'id': 'e205bf79-a36f-412c-af09-b66265a3fde1', 'name': 'E', 'value': [], 'type_hint': None, 'description': None}
# INFO: C vector for C_state_observation set to default zeros.
# INFO: DEBUG: convert_D_vector: self.D_spec = None
# INFO: DEBUG: _extract_initial_parameterization_matrices: initial_params = {'node_type': 'Parameter', 'source_location': None, 'metadata': {}, 'id': 'e205bf79-a36f-412c-af09-b66265a3fde1', 'name': 'E', 'value': [], 'type_hint': None, 'description': None}
# INFO: D vector for D_location set to default uniform.
# INFO: DEBUG: convert_E_vector: self.E_spec = None
# INFO: DEBUG: _extract_initial_parameterization_matrices: initial_params = {'node_type': 'Parameter', 'source_location': None, 'metadata': {}, 'id': 'e205bf79-a36f-412c-af09-b66265a3fde1', 'name': 'E', 'value': [], 'type_hint': None, 'description': None}
# INFO: E_vector: No E (policy prior) specification found. Defaulting to None.
# INFO: Agent instantiation code not generated yet. Generating...
# INFO: Example usage code not generated yet. Generating...
# --- End of GNN to PyMDP Conversion Summary ---


A_state_observation = utils.norm_dist(np.ones((3, 3)))
A = np.empty(1, dtype=object)
A[0] = A_state_observation
B_location = utils.norm_dist(np.ones(3, 3, 3))
B = np.empty(1, dtype=object)
B[0] = B_location
C_state_observation = np.zeros(3)
C = np.empty(1, dtype=object)
C[0] = C_state_observation
D_location = np.ones(3) / 3.0
D = np.empty(1, dtype=object)
D[0] = D_location
E = None

agent = Agent(
    A=A,
    B=B,
    C=C,
    D=D,
    E=E,
    control_fac_idx=[0]
)

# Set action names as agent attribute
agent.action_names = {}


# Example usage of the agent
if __name__ == "__main__":
    
    # --- Example Usage ---
    if __name__ == '__main__':
        # Initialize agent (already done above)
        # agent = pymdp_agent_model  # Agent is already instantiated above as 'agent'
        print(f"Agent 'pymdp_agent_model' initialized with {agent.num_factors if hasattr(agent, 'num_factors') else 'N/A'} factors and {agent.num_modalities if hasattr(agent, 'num_modalities') else 'N/A'} modalities.")
        # Define names for display purposes
        obs_names = [f'Modality_{i}' for i in range(1)] if 1 > 0 else []
        state_names = [f'Factor_{i}' for i in range(1)] if 1 > 0 else []
        num_modalities = 1
        num_factors = 1
        control_fac_idx = [0]
        o_current = [0] # Example initial observation (e.g. first outcome for each modality)
        s_current = [0] # Example initial true states for simulation
        T = 5 # Number of timesteps
        A_gen_process = copy.deepcopy(A)
        B_gen_process = copy.deepcopy(B)
    
        for t_step in range(T):
            print(f"\n--- Timestep {t_step + 1} ---")
            if o_current is not None:
                for g_idx, o_val in enumerate(o_current):
                    print(f"Observation ({obs_names[g_idx] if obs_names else f'Modality {g_idx}'}): {o_val}")
            # Infer states
            qs_current = agent.infer_states(o_current)
            if qs_current is not None:
                for f_idx, q_val in enumerate(qs_current):
                    print(f"Beliefs about {state_names[f_idx] if state_names else f'Factor {f_idx}'}: {q_val}")
    
            # Infer policies and sample action
            q_pi_current, efe_current = agent.infer_policies()
            if hasattr(agent, 'q_pi') and agent.q_pi is not None:
                print(f"Posterior over policies (q_pi): {agent.q_pi}")
            if efe_current is not None:
                print(f"Expected Free Energy (EFE): {efe_current}")
            action_agent = agent.sample_action()
            # Map agent's action (on control factors) to full environment action vector
            action_env = np.zeros(num_factors, dtype=int)
            if control_fac_idx and action_agent is not None:
                for i, cf_idx in enumerate(control_fac_idx):
                    action_env[cf_idx] = int(action_agent[i])
            # Construct action names for printing
            action_names_str_list = []
            if control_fac_idx and action_agent is not None:
                for i, cf_idx in enumerate(control_fac_idx):
                    factor_action_name_list = agent.action_names.get(cf_idx, []) if hasattr(agent, 'action_names') and isinstance(agent.action_names, dict) else []
                    action_idx_on_factor = int(action_agent[i])
                    if factor_action_name_list and action_idx_on_factor < len(factor_action_name_list):
                        action_names_str_list.append(f"{state_names[cf_idx] if state_names else f'Factor {cf_idx}'}: {factor_action_name_list[action_idx_on_factor]} (idx {action_idx_on_factor})")
                    else:
                        action_names_str_list.append(f"{state_names[cf_idx] if state_names else f'Factor {cf_idx}'}: Action idx {action_idx_on_factor}")
            print(f"Action taken: {', '.join(action_names_str_list) if action_names_str_list else 'No controllable actions or names not found'}")
    
            # Update true states of the environment based on action
            s_next = np.zeros(num_factors, dtype=int)
            if s_current is not None and B_gen_process is not None:
                for f_idx in range(num_factors):
                    # B_gen_process[f_idx] shape: (num_states[f_idx], num_states[f_idx], num_actions_for_this_factor_or_1)
                    action_for_factor = action_env[f_idx] if f_idx in control_fac_idx else 0
                    s_next[f_idx] = utils.sample(B_gen_process[f_idx][:, s_current[f_idx], action_for_factor])
            s_current = s_next.tolist()
            if s_current is not None:
                for f_idx, s_val in enumerate(s_current):
                    print(f"New true state ({state_names[f_idx] if state_names else f'Factor {f_idx}'}): {s_val}")
    
            # Generate next observation based on new true states
            o_next = np.zeros(num_modalities, dtype=int)
            if s_current is not None and A_gen_process is not None:
                for g_idx in range(num_modalities):
                    # A_gen_process[g_idx] shape: (num_obs[g_idx], num_states[0], num_states[1], ...)
                    # Construct index for A matrix: (outcome_idx, s_f0, s_f1, ...)
                    prob_vector = A_gen_process[g_idx][:, s_current[0]]
                    o_next[g_idx] = utils.sample(prob_vector)
            o_current = o_next.tolist()
    
        print(f"\nSimulation finished after {T} timesteps.")


print('--- PyMDP Runtime Debug ---')
try:
    import pymdp
    import inspect 
    import traceback 
    import ast
    import json
    import os
    from datetime import datetime
    from pathlib import Path

    from pymdp.agent import Agent
    print(f'AGENT_SCRIPT: Imported Agent: {Agent}')
    print(f'AGENT_SCRIPT: Agent module location: {inspect.getfile(Agent)}')
    print('AGENT_SCRIPT: Checking for required variables in global scope:')
    print(f"  AGENT_SCRIPT: A = {A if 'A' in globals() else 'Not Defined'}")
    print(f"  AGENT_SCRIPT: B = {B if 'B' in globals() else 'Not Defined'}")
    print(f"  AGENT_SCRIPT: C = {C if 'C' in globals() else 'Not Defined'}")
    print(f"  AGENT_SCRIPT: D = {D if 'D' in globals() else 'Not Defined'}")
    print(f"  AGENT_SCRIPT: E = {E if 'E' in globals() else 'Not Defined'}")
    print(f"  AGENT_SCRIPT: control_fac_idx = {control_fac_idx if 'control_fac_idx' in globals() else 'Not Defined'}")
    print('  AGENT_SCRIPT: action_names = {}')
    print('  AGENT_SCRIPT: qs_initial = None')
    print('  AGENT_SCRIPT: agent_hyperparams = {}')
    
    # Save matrix information to file if PYMDP_OUTPUT_DIR is set
    output_dir_env = os.environ.get('PYMDP_OUTPUT_DIR')
    if output_dir_env:
        output_dir = Path(output_dir_env)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        # Save matrix information
        matrix_info = {
            "timestamp": datetime.now().isoformat(),
            "script_name": __file__ if '__file__' in globals() else "unknown_script",
            "matrices": {
                "A": str(A) if 'A' in globals() and A is not None else None,
                "B": str(B) if 'B' in globals() and B is not None else None,
                "C": str(C) if 'C' in globals() and C is not None else None,
                "D": str(D) if 'D' in globals() and D is not None else None,
                "E": str(E) if 'E' in globals() and E is not None else None
            },
            "parameters": {
                "control_fac_idx": str(control_fac_idx) if 'control_fac_idx' in globals() else None,
                "action_names": "{}",
                "qs_initial": "None",
                "agent_hyperparams": "{}"
            }
        }
        
        matrix_file = output_dir / "matrices_extracted.json"
        with open(matrix_file, 'w') as f:
            json.dump(matrix_info, f, indent=2)
        print(f'AGENT_SCRIPT: Saved matrix information to {matrix_file}')
    
    print('AGENT_SCRIPT: Attempting to instantiate agent with defined parameters for debug...')
    
    local_agent_hyperparams_str_val = '{}'

    agent_params_for_debug = {}
    if local_agent_hyperparams_str_val and local_agent_hyperparams_str_val.strip() and local_agent_hyperparams_str_val.strip() != '{}':
        try:
            agent_params_for_debug = ast.literal_eval(local_agent_hyperparams_str_val)
            if not isinstance(agent_params_for_debug, dict):
                print("AGENT_SCRIPT: Debug - Parsed agent_hyperparams_dict_str ('" + local_agent_hyperparams_str_val + "') was not a dict.")
                agent_params_for_debug = {} 
        except Exception as e_hyper_parse:
            print("AGENT_SCRIPT: Debug - Error parsing agent_hyperparams_dict_str ('" + local_agent_hyperparams_str_val + "'): " + str(e_hyper_parse))
            agent_params_for_debug = {}
    else:
        print("AGENT_SCRIPT: Debug - agent_hyperparams_dict_str ('" + local_agent_hyperparams_str_val + "') is empty or '{}'. Using empty dict for debug agent.")
    
    debug_params_copy = {k: v for k, v in agent_params_for_debug.items() if not (isinstance(v, str) and v == 'None')}
    
    # Attempt agent instantiation and save results
    agent_instantiation_result = {
        "timestamp": datetime.now().isoformat(),
        "success": False,
        "error": None,
        "agent_info": None
    }
    
    try:
        temp_agent = Agent(**debug_params_copy)
        print(f'AGENT_SCRIPT: Debug agent successfully instantiated: {temp_agent}')
        agent_instantiation_result["success"] = True
        agent_instantiation_result["agent_info"] = str(temp_agent)
        
        # Save successful instantiation info
        if output_dir_env:
            instantiation_file = output_dir / "agent_instantiation_result.json"
            with open(instantiation_file, 'w') as f:
                json.dump(agent_instantiation_result, f, indent=2)
            print(f'AGENT_SCRIPT: Saved agent instantiation result to {instantiation_file}')
            
    except Exception as e_agent:
        agent_instantiation_result["success"] = False
        agent_instantiation_result["error"] = str(e_agent)
        print(f'AGENT_SCRIPT: Error during agent instantiation: {e_agent}')
        
        # Save failed instantiation info
        if output_dir_env:
            instantiation_file = output_dir / "agent_instantiation_result.json"
            with open(instantiation_file, 'w') as f:
                json.dump(agent_instantiation_result, f, indent=2)
            print(f'AGENT_SCRIPT: Saved agent instantiation error to {instantiation_file}')
        
except Exception as e_debug:
    print(f'AGENT_SCRIPT: Error during PyMDP runtime debug: {e_debug}')
    print("AGENT_SCRIPT: Traceback:")
    print(traceback.format_exc())
    
    # Save debug error if possible
    output_dir_env = os.environ.get('PYMDP_OUTPUT_DIR')
    if output_dir_env:
        try:
            output_dir = Path(output_dir_env)
            output_dir.mkdir(parents=True, exist_ok=True)
            
            error_info = {
                "timestamp": datetime.now().isoformat(),
                "error": str(e_debug),
                "traceback": traceback.format_exc()
            }
            
            error_file = output_dir / "debug_error.json"
            with open(error_file, 'w') as f:
                json.dump(error_info, f, indent=2)
            print(f'AGENT_SCRIPT: Saved debug error to {error_file}')
        except Exception as e_save:
            print(f'AGENT_SCRIPT: Could not save debug error: {e_save}')
            
print('--- End PyMDP Runtime Debug ---')
